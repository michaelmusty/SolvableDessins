/*
Front Matter
*/
  // assumes current directory = repo directory
  dir := GetCurrentDirectory();
  parentdir := Pipe(Sprintf("basename 'dirname %o'", dir), "");
  if parentdir eq "SolvableDessins\n" then
    repo := dir;
  else
    error "make sure your working directory is /SolvableDessins";
  end if;
  // directories in SolvableDessins repo
  code := repo cat "/Code/";
  db := repo cat "/SolvableDB/";
  profiler := repo cat "/Profiler/";
  examples := repo cat "/Examples/";
  // spec files
  AttachSpec(code cat "spec");
  AttachSpec("~/Dropbox/belyi/Code/spec");
/*
MAIN
*/
j := 1; // which 2T1 you want?
names := SolvableDBFilenames(2);
objs := [];
for i in [1..#names] do
  s := SolvableDBAccessEntry(names[i]);
  pass := s`SolvableDBPassport;
  Append(~objs, SolvableDBExample(pass));
end for;
s := objs[j];
// algebraic function field constant field AND curve base field
  F := Rationals();
  // F<nu> := NumberField(Polynomial([1,-1,1]));
// level 0 Setup AFF
  R0<x0> := PolynomialRing(F);
  K0<x0> := FunctionField(F);
// level 0 Curve FF
  PX0<x0> := PolynomialRing(F, 1);
  AA0<x0> := AffineSpace(PX0);
  I0<x0> := ideal< PX0 | [] >;
  X0<x0> := Curve(AA0);
  KX0<x0> := FunctionField(X0);
  phi0 := KX0.1;
// level 0 AlgorithmicFunctionField
  AK0, mpKX0toAK0 := AlgorithmicFunctionField(KX0);
// level 0 RiemannRoch
  f0 := K0.1-1;
// level 1 Setup AFF
  P1<x1> := PolynomialRing(K0);
  a1 := P1.1^2-f0;
  K1 := ext< K0 | a1 >;
  R1 := IntegralClosure(R0, K1);
// level 1 Curve FF
  PX1<x0, x1> := PolynomialRing(F, 2);
  AA1<x0, x1> := AffineSpace(PX1);
  mpK0toPX1 := hom< K0 -> PX1 | PX1.1 >;
  mpK1toPX1 := hom< K1 -> PX1 | mpK0toPX1, PX1.2 >;
  poly1 := PX1.2^2-mpK1toPX1(f0);
  I1 := ideal< PX1 | poly1 >; // P1!x1^2-f0 = P1!x1^2-x0
  X1<x0, x1> := Curve(AA1, I1);
  KX1<x0, x1> := FunctionField(X1);
  phi1 := KX1.1;
// level 1 SanityCheck
  sigma := s`SolvableDBPassport[1];
  BelyiMapSanityCheck(sigma, X1, phi1);
// level 1 AlgorithmicFunctionField
  AK1, mpKX1toAK1 := AlgorithmicFunctionField(KX1);
  AR1 := MaximalOrderFinite(AK1);
  D1_0 := Divisor(mpKX1toAK1(KX1.1));
  D1_1 := Divisor(mpKX1toAK1(KX1.1-1));
  assert #InfinitePlaces(AK1) eq 1;
  D1_oo := Divisor(InfinitePlaces(AK1)[1]);
// level 1 RiemannRoch
// write
/*
  s`SolvableDBAlgebraicFunctionFieldConstantField := F;
  s`SolvableDBAlgebraicFunctionFieldPolynomialRingList := [* P0, P1 *];
  s`SolvableDBAlgebraicFunctionFieldList := [* K0, K1 *];
  s`SolvableDBAlgebraicFunctionFieldExtractedSqrtList := [* f0 *];
  s`SolvableDBCurveBaseField := F;
  s`SolvableDBCurvePolynomialRingList := [* PX0, PX1 *];
  s`SolvableDBCurveAmbientList := [* AA0, AA1 *];
  s`SolvableDBCurveIdealList := [* I0, I1 *];
  s`SolvableDBCurveList := [* X0, X1 *];
  s`SolvableDBBelyiCurve := X1;
  s`SolvableDBBelyiMap := phi1;
*/

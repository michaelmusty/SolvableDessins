load "catalog.mag";
SetVerbose("Solvable", 0);
below := [ PermutationGroup<8 |
\[ 7, 8, 1, 2, 3, 4, 5, 6 ],
\[ 2, 1, 8, 7, 6, 5, 4, 3 ],
\[ 8, 7, 6, 5, 4, 3, 2, 1 ]:
 Order := 8 > |
[ 7, 8, 1, 2, 3, 4, 5, 6 ],
[ 2, 1, 8, 7, 6, 5, 4, 3 ],
[ 8, 7, 6, 5, 4, 3, 2, 1 ]
];
G := sub<Sym(8)|below>;
extensions := Extensions(below);
extension := extensions[2];
E, iotaE, piE := Explode(extension);
g := Image(iotaE).1; // element of E conjugate to tau
tau := IdentifyingTau(4);
blocks := IdentifyingBlocks(4);
b, c := IsConjugate(Sym(16), g, tau);
Ec := Conjugate(E, c);
Ecblocks := GSet(Ec, blocks);
assert IsIsomorphic(G, ActionImage(Ec, Ecblocks));
above := [(below[i] @@ piE)^c : i in [1..3]];
above;
blocks;
ActionImage(Ec, Ecblocks);
below;
TestBlockAction(above, below);

C := Centralizer(Sym(16), tau);
worked := [];
count := 0;
for d in C do
  count +:= 1;
  printf "%o out of %o\n", count, #C;
  above_d := [ above[i]^d : i in [1..3]];
  if TestBlockAction(above_d, below) then
    Append(~worked, d);
  end if;
end for;
above_new := [above[i]^worked[1] : i in [1..3]];

Gt := sub<Sym(16)|above_new>;
Gtblocks := GSet(Gt, blocks);
above_new;
blocks;
ActionImage(Gt, Gtblocks);
below;
TestBlockAction(above_new, below);

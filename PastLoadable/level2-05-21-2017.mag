/*
Front Matter
*/
  // assumes current directory = repo directory
  dir := GetCurrentDirectory();
  parentdir := Pipe(Sprintf("basename 'dirname %o'", dir), "");
  if parentdir eq "SolvableDessins\n" then
    repo := dir;
  else
    error "make sure your working directory is /SolvableDessins";
  end if;
  // directories in SolvableDessins repo
  code := repo cat "/Code/";
  db := repo cat "/SolvableDB/";
  profiler := repo cat "/Profiler/";
  examples := repo cat "/Examples/";
  // spec files
  AttachSpec(code cat "spec");
  AttachSpec("~/Dropbox/belyi/Code/spec");
/*
MAIN
*/
j := 1; // which 2T1 you want?
names := SolvableDBFilenames(2);
objs := [];
for i in [1..#names] do
  s := SolvableDBAccessEntry(names[i]);
  pass := s`SolvableDBPassport;
  Append(~objs, SolvableDBExample(pass));
end for;
s := objs[j];
// algebraic function field constant field AND curve base field
  F<nu> := RationalsAsNumberField();
// level 0 Setup AFF
  P0<x0> := PolynomialRing(F);
  K0<x0> := FunctionField(F);
  R0<x0> := RingOfIntegers(K0);
// level 0 Curve FF
  PX0<x0> := PolynomialRing(F, 1);
  AA0<x0> := AffineSpace(PX0);
  I0<x0> := ideal< PX0 | [] >;
  X0<x0> := Curve(AA0);
  KX0<x0> := FunctionField(X0);
  phi0 := KX0.1;
// level 0 RiemannRoch
  f0 := K0.1-1;
// level 1 Setup AFF
  P1<x1> := PolynomialRing(K0);
  a1 := P1.1^2-f0;
  K1 := ext< K0 | a1 >;
  R1 := IntegralClosure(R0, K1);
// level 1 Curve FF
  PX1<x0, x1> := PolynomialRing(F, 2);
  AA1<x0, x1> := AffineSpace(PX1);
  mpK0toPX1 := hom< K0 -> PX1 | PX1.1 >;
  mpK1toPX1 := hom< K1 -> PX1 | mpK0toPX1, PX1.2 >;
  poly1 := PX1.2^2-mpK1toPX1(f0);
  I1 := ideal< PX1 | poly1 >; // P1!x1^2-f0 = P1!x1^2-x0
  X1<x0, x1> := Curve(AA1, I1);
  KX1<x0, x1> := FunctionField(X1);
  phi1 := KX1.1;
// level 1 RiemannRoch
  I1_0 := ideal< R1 | R1!f0-1 >;
  I1_1 := ideal< R1 | R1!f0 >;
  assert #InfinitePlaces(K1) eq 1;
  I1_oo := Ideal(InfinitePlaces(K1)[1]);
  pp1_0a := Factorization(I1_0)[1][1];
  pp1_0b := Factorization(I1_0)[2][1];
  pp1_1 := Factorization(I1_1)[1][1];
  pp1_oo := Factorization(I1_oo)[1][1];
  D1 := Divisor(pp1_0a) - Divisor(pp1_0b) + Divisor(pp1_1) - Divisor(pp1_oo);
  LD1, mpLD1toK1 := RiemannRochSpace(D1);
  assert Dimension(LD1) eq 1;
  f1 := mpLD1toK1(LD1.1);
// level 2 Setup AFF
  P2<x2> := PolynomialRing(K1);
  a2 := P2.1^2-f1;
  K2 := ext< K1 | a2 >;
  R2 := IntegralClosure(R0, K2);
// level 2 Curve FF
  PX2<x0, x1, x2> := PolynomialRing(F, 3);
  AA2<x0, x1, x2> := AffineSpace(PX2);
  mpK0toPX2 := hom< K0 -> PX2 | PX2.1 >;
  mpK1toPX2 := hom< K1 -> PX2 | mpK0toPX2, PX2.2 >;
  denom1 := Denominator(f1, R1);
  f1 := denom1*f1;
  f1 := mpK1toPX2(f1);
  denom1 := mpK1toPX2(denom1);
  poly2 := denom1*PX2.3^2 - f1;
  assert Parent(poly2) eq PX2;
  mpPX1toPX2 := hom< PX1 -> PX2 | PX2.1, PX2.2 >;
  I2 := ideal< PX2 | mpPX1toPX2(poly1), poly2 >;
  Qs, Ps := PrimaryDecomposition(I2);
  X2<x0, x1, x2> := Curve(AA2, Ps[1]);
  KX2<x0, x1, x2> := FunctionField(X2);
  phi2 := KX2.1;
// level 2 RiemannRoch

// sanity
  sigma := s`SolvableDBPassport[1];
  covers := PossibleGaloisCoveringPermutationTriples(sigma);
  sigma := covers[3];
  BelyiMapSanityCheck(sigma, X2, phi2);
// write
/*
  s`SolvableDBAlgebraicFunctionFieldConstantField := F;
  s`SolvableDBAlgebraicFunctionFieldPolynomialRingList := [* P0, P1 *];
  s`SolvableDBAlgebraicFunctionFieldList := [* K0, K1 *];
  s`SolvableDBAlgebraicFunctionFieldExtractedSqrtList := [* f0 *];
  s`SolvableDBCurveBaseField := F;
  s`SolvableDBCurvePolynomialRingList := [* PX0, PX1 *];
  s`SolvableDBCurveAmbientList := [* AA0, AA1 *];
  s`SolvableDBCurveIdealList := [* I0, I1 *];
  s`SolvableDBCurveList := [* X0, X1 *];
  s`SolvableDBBelyiCurve := X1;
  s`SolvableDBBelyiMap := phi1;
*/

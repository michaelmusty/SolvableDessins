/*
Front Matter
*/
  // assumes current directory = repo directory
  dir := GetCurrentDirectory();
  parentdir := Pipe(Sprintf("basename 'dirname %o'", dir), "");
  if parentdir eq "SolvableDessins\n" then
    repo := dir;
  else
    error "make sure your working directory is /SolvableDessins";
  end if;
  // directories in SolvableDessins repo
  code := repo cat "/Code/";
  db := repo cat "/SolvableDB/";
  profiler := repo cat "/Profiler/";
  examples := repo cat "/Examples/";
  // spec files
  AttachSpec(code cat "spec");
  AttachSpec("~/Dropbox/belyi/Code/spec");
/*
MAIN
*/
j := 1; // which 2T1 you want?
names := SolvableDBFilenames(2);
objs := [];
for i in [1..#names] do
  s := SolvableDBAccessEntry(names[i]);
  pass := s`SolvableDBPassport;
  Append(~objs, SolvableDBExample(pass));
end for;
s := objs[j];
// algebraic function field constant field AND curve base field
  F<nu> := RationalsAsNumberField();
// level 0 Setup AFF
  P0<x0> := PolynomialRing(F);
  K0<x0> := FunctionField(F);
  R0<x0> := RingOfIntegers(K0);
  assert P0 eq R0;
// level 0 Curve FF
  PX0<x0> := PolynomialRing(F, 1);
  AA0<x0> := AffineSpace(PX0);
  I0<x0> := ideal< PX0 | [] >;
  X0<x0> := Curve(AA0);
  KX0<x0> := FunctionField(X0);
  phi0 := KX0.1;
// level 0 RiemannRoch
  f0 := K0.1-1;
// level 1 Setup AFF
  P1<x1> := PolynomialRing(K0);
  a1 := P1.1^2-f0;
  K1 := ext< K0 | a1 >;
  R1 := IntegralClosure(R0, K1);
// level 1 Curve FF
  PX1<x0, x1> := PolynomialRing(F, 2);
  AA1<x0, x1> := AffineSpace(PX1);
  mpK0toPX1 := hom< K0 -> PX1 | PX1.1 >;
  mpK1toPX1 := hom< K1 -> PX1 | mpK0toPX1, PX1.2 >;
  poly1 := PX1.2^2-mpK1toPX1(f0);
  I1 := ideal< PX1 | poly1 >; // P1!x1^2-f0 = P1!x1^2-x0
  X1<x0, x1> := Curve(AA1, I1);
  KX1<x0, x1> := FunctionField(X1);
  phi1 := KX1.1;
// level 1 RiemannRoch
  // I1_0 := ideal< R1 | f0 >;
  // I1_1 := ideal< R1 | f0 - 1 >;
  I1_0 := ideal< R1 | R1!f0-1 >;
  I1_1 := ideal< R1 | R1!f0 >;
  assert #InfinitePlaces(K1) eq 1;
  I1_oo := Ideal(InfinitePlaces(K1)[1]);
  pp1_0a := Factorization(I1_0)[1][1];
  pp1_0b := Factorization(I1_0)[2][1];
  pp1_1 := Factorization(I1_1)[1][1];
  pp1_oo := Factorization(I1_oo)[1][1];
// sanity
  sigma := s`SolvableDBPassport[1];
  BelyiMapSanityCheck(sigma, X1, phi1);
// write
/*
  s`SolvableDBAlgebraicFunctionFieldConstantField := F;
  s`SolvableDBAlgebraicFunctionFieldPolynomialRingList := [* P0, P1 *];
  s`SolvableDBAlgebraicFunctionFieldList := [* K0, K1 *];
  s`SolvableDBAlgebraicFunctionFieldExtractedSqrtList := [* f0 *];
  s`SolvableDBCurveBaseField := F;
  s`SolvableDBCurvePolynomialRingList := [* PX0, PX1 *];
  s`SolvableDBCurveAmbientList := [* AA0, AA1 *];
  s`SolvableDBCurveIdealList := [* I0, I1 *];
  s`SolvableDBCurveList := [* X0, X1 *];
  s`SolvableDBBelyiCurve := X1;
  s`SolvableDBBelyiMap := phi1;
*/

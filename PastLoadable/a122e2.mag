load "catalog.mag";
SetVerbose("Solvable", 0);
f := SolvableDBFilenames(2);
s := SolvableDBAccessEntry(f[1]);
below := s`SolvableDBGaloisOrbit[1];
G := sub<Sym(2)|below>;
extensions := Extensions(below);
extension := extensions[1];
E, iota, pi := Explode(extension);
A := Image(iota);
tau := A.1;
above := [ below[i] @@ pi : i in [1..3] ];
blocks := PermutationToBlocks(A.1);
blocks := GSet(E, blocks);
assert CorrectInducedActions(extension, below);

a1, a2, a3 := Explode(above);
covers := [above];
Append(~covers, [tau*a1, a2, a3]);
Append(~covers, [a1, tau*a2, a3]);
Append(~covers, [a1, a2, tau*a3]);
Append(~covers, [a1, tau*a2, tau*a3]);
Append(~covers, [tau*a1, a2, tau*a3]);
Append(~covers, [tau*a1, tau*a2, a3]);
Append(~covers, [tau*a1, tau*a2, tau*a3]);

correct := [];
for i := 1 to #covers do
  printf "i=%o:\n", i;
  cover := covers[i];
  test_action := TestBlockAction(cover, below, blocks);
  if cover[3]*cover[2]*cover[1] eq Id(Parent(cover[1])) then
    test_id := true;
  else
    test_id := false;
  end if;
  printf "  action? %o\n", test_action;
  printf "  identity? %o\n", test_id;
  if test_action and test_id then
    Append(~correct, cover);
  end if;
end for;

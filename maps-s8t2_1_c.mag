/*
Front Matter
*/
  // assumes current directory = repo directory
  dir := GetCurrentDirectory();
  parentdir := Pipe(Sprintf("basename 'dirname %o'", dir), "");
  if parentdir eq "SolvableDessins\n" then
    repo := dir;
  else
    error "make sure your working directory is /BelyiDB";
  end if;
  // directories in SolvableDessins repo
  code := repo cat "/Code/";
  db := repo cat "/SolvableDB/";
  profiler := repo cat "/Profiler/";
  examples := repo cat "/Examples/";
  // spec files
  AttachSpec(code cat "spec");
  AttachSpec("~/Dropbox/belyi/Code/spec");

/*
MAIN
*/

load "catalog.mag";

/*
BASE FIELD
*/
K := Rationals();

/*
LEVEL 0: PP1
*/
// curve and FldFunFracSch
  P0<x0> := PolynomialRing(K, 1);
  AA1<x0> := AffineSpace(P0);
  Y0<x0> := Curve(AA1);
  X0<z0, w> := ProjectiveClosure(Y0);
  KX0<x0> := FunctionField(X0);
// algebraic function field
  K0<x0> := FunctionField(K);
  R0<x0> := RingOfIntegers(K0);
  f0 := K0.1; // K0!x0;
  phi00 := hom< K0 -> P0 | P0.1 >;

/*
Degree 2
Level 1
X1 -> PP1
*/
// setup algebraic function field
  P1<x1> := PolynomialRing(K0);
  a1 := x1^2-f0;
  K1<x1> := ext< K0 | a1 >;
  R1 := IntegralClosure(R0, K1);
// curve and FldFunFracSch
  P1<x0, x1> := PolynomialRing(K, 2);
  AA2<x0, x1> := AffineSpace(P1);
  assert K0 eq CoefficientField(K1);
  phi01 := hom< K0 -> P1 | P1.1 >;
  phi11 := hom< K1 -> P1 | phi01, P1.2 >;
  poly1 := P1.2^2-phi11(f0);
  I1 := ideal< P1 | poly1 >; // P1!x1^2-f0 = P1!x1^2-x0
  Y1<x0, x1> := Curve(AA2, I1);
  X1<z0, z1, w> := ProjectiveClosure(Y1);
  KX1<x0, x1> := FunctionField(X1);
  belyimap1 := KX1!x0;
// ideals
  I1_0 := ideal< R1 | R1!K0.1 >;
  I1_1 := ideal< R1 | R1!K0.1-1>;
  assert #InfinitePlaces(K1) eq 1;
  I1_oo := Ideal(InfinitePlaces(K1)[1]);
// primes
  fact1_0 := Factorization(I1_0);
  fact1_1 := Factorization(I1_1);
  fact1_oo := Factorization(I1_oo);
  assert #fact1_0 eq 1;
  assert #fact1_1 eq 2;
  assert #fact1_oo eq 1;
  pp1_0 := fact1_0[1][1];
  pp1_1a := fact1_1[1][1];
  pp1_1b := fact1_1[2][1];
  pp1_oo := fact1_oo[1][1];
// RiemannRoch
  D1 := Divisor(pp1_1a) - Divisor(pp1_1b);
  // D1 := Divisor(pp1_0) - Divisor(pp1_oo);
  LD1, mp1 := RiemannRochSpace(D1);
  assert Dimension(LD1) eq 1;
  f1 := mp1(LD1.1);

/*
Degree 4
Level 2
X2 -> PP1
s4t2_1
*/
// setup algebraic function field
  P2<x2> := PolynomialRing(K1);
  a2 := x2^2-f1;
  K2<x2> := ext< K1 | a2 >;
  R2 := IntegralClosure(R1, K2);
// curve and FldFunFracSch
  P2<x0, x1, x2> := PolynomialRing(K, 3);
  AA3<x0, x1, x2> := AffineSpace(P2);
  // map x2^2-f1 to P2
  denom1 := Denominator(f1, R1);
  f1 := denom1*f1; // still in K1
  h := hom< Parent(denom1) -> P2 | P2.1 >;
  denom1 := h(denom1); // now lives in P2
  h0 := hom< K0 -> P2 | P2.1 >;
  h1 := hom< K1 -> P2 | h0, P2.2 >;
  f1 := h1(f1);
  poly2 := denom1*P2.3^2-f1;
  h := hom< P1 -> P2 | P2.1, P2.2 >;
  I2 := ideal< P2 | h(poly1), poly2 >;
  // fiddle with I2
  Qs, Ps := PrimaryDecomposition(I2);
  Y2<x0, x1, x2> := Curve(AA3, Ps[1]);
  X2<z0, z1, z2, w> := ProjectiveClosure(Y2);
  KX2<x0, x1, x2> := FunctionField(X2);
  belyimap2 := KX2!x0;
// ideals
  I2_0 := ideal< R2 | R2!K0.1 >;
  I2_1 := ideal< R2 | R2!K0.1-1>;
  assert #InfinitePlaces(K2) eq 1;
  I2_oo := Ideal(InfinitePlaces(K2)[1]);
// primes
  fact2_0 := Factorization(I2_0);
  fact2_1 := Factorization(I2_1);
  fact2_oo := Factorization(I2_oo);
  pp2_0 := fact2_0[1][1];
  pp2_1a := fact2_1[1][1];
  pp2_1b := fact2_1[2][1];
  pp2_oo := fact2_oo[1][1];
// RiemannRoch
  // D2 := Divisor(pp2_0) + Divisor(pp2_1a) - Divisor(pp2_1b) - Divisor(pp2_oo);
  // D2 := Divisor(pp2_1a) + Divisor(pp2_1b) - Divisor(pp2_oo);
  D2 := Divisor(pp2_0) - Divisor(pp2_1a) - Divisor(pp2_1b);
  LD2, mp2 := RiemannRochSpace(D2);
  assert Dimension(LD2) eq 1;
  f2 := mp2(LD2.1);

/*
Degree 8
Level 3
X3 -> PP1
s8t2_1_a
*/
// setup algebraic function field
  P3<x3> := PolynomialRing(K2);
  a3 := x3^2-K2!f2;
  K3<x3> := ext< K2 | a3 >;
  R3 := IntegralClosure(R2, K3);
// curve and FldFunFracSch
  P3<x0, x1, x2, x3> := PolynomialRing(K, 4);
  AA4<x0, x1, x2, x3> := AffineSpace(P3);
  denom2 := Denominator(K2!f2, R2);
  f2 := K2!denom2*f2; // still in K2
  h := hom< Parent(denom2) -> P3 | P3.1 >;
  denom2 := h(denom2); // now lives in P3
  h0 := hom< K0 -> P3 | P3.1 >;
  h1 := hom< K1 -> P3 | h0, P3.2 >;
  h2 := hom< K2 -> P3 | h1, P3.3 >;
  h := hom< Parent(f1) -> P3 | P3.1, P3.2, P3.3 >; // Parent(f1) is P2
  f1 := h(f1);
  f2 := h2(K2!f2);
  poly3 := denom2*P3.4^2-f2;
  h := hom< P1 -> P3 | P3.1, P3.2 >;
  poly1 := h(poly1);
  h := hom< P2 -> P3 | P3.1, P3.2, P3.3 >;
  poly2 := h(poly2);
  //
  I3 := ideal< P3 | poly1, poly2, poly3 >;
  Qs, Ps := PrimaryDecomposition(I3);
  Y3<x0, x1, x2, x3> := Curve(AA4, Ps[1]);
  X3<z0, z1, z2, z3, w> := ProjectiveClosure(Y3);
  KX3<x0, x1, x2, x3> := FunctionField(X3);
  belyimap3 := KX3!x0;

  pass := s8t2_1_c`SolvableDBPassport;
  assert BelyiMapSanityCheck(pass[1], Y3, belyimap3);

/*
Front Matter
*/
  // assumes current directory = repo directory
  dir := GetCurrentDirectory();
  parentdir := Pipe(Sprintf("basename 'dirname %o'", dir), "");
  if parentdir eq "SolvableDessins\n" then
    repo := dir;
  else
    error "make sure your working directory is /BelyiDB";
  end if;
  // directories in SolvableDessins repo
  code := repo cat "/Code/";
  db := repo cat "/SolvableDB/";
  profiler := repo cat "/Profiler/";
  examples := repo cat "/Examples/";
  // spec files
  AttachSpec(code cat "spec");
  AttachSpec("~/Dropbox/belyi/Code/spec");

/*
MAIN
*/
  // using the catalog
  load "catalog16.mag";
  sigma := d16t12;

/*
PERMUTATIONS, PARTITIONS, and RAMIFICATION DATA
*/
  // convert sigma to partitions
  parts_below := PermutationTripleToPartitions(sigma);
  // check if valid partition triple
  check_parts_below := ValidPartitionTriple(parts_below);
  // random ramification data for sigma
  rams := RandomRamificationData(sigma);
  // partitions of covering permutation triple for given ramification data
  parts_above := ShapeOfCoveringPermutationTriple(sigma, rams);
  // the excess of a permutation
  excess0 := Excess(sigma[1]);
  // genus of sigma
  g := Genus(sigma);
  g_below := Genus(parts_below);
  g_above := Genus(parts_above);
  // check if genus is valid
  IsGenus(sigma);
  IsGenus(parts_below);
  IsGenus(parts_above);
  // check if given sigma and ramification data yields a covering partition triple with valid genus
  IsPossibleRamification(sigma, rams);
  // IntegerToBinary, IntegerToGaloisRamification
  for a in [0..(2^3-1)] do
    print IntegerToBinary(a, 3);
    rams := IntegerToGaloisRamification(a, sigma);
    print rams;
    print IsPossibleRamification(sigma, rams);
  end for;
  // PossibleRamifications
  galrams := PossibleRamifications(sigma);
  // change ramification data to partitions
  // these are the partition triples that are possible for Galois covers of sigma
  shapes := PossibleShapesOfCoveringPermutationTriples(sigma);

/*
IDENTIFYING SHEETS
*/
// identifying tau
tau := IdentifyingTau(5);
// PermutationToCode
tau_code := PermutationToCode(tau);
// CodeToPermutation
CodeToPermutation(tau_code) eq tau;
// ModifyCode(code, index, new), CodeEntry(code, index)
/*
G := Sym(1024);
start := Cputime();
for i in [1..10000] do
  s := Random(G);
  sc := PermutationToCode(s);
  CodeEntry(sc, 1000);
end for;
done := Cputime();
t := done - start;
*/

/*
MISC
*/

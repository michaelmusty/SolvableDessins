intrinsic IdentifyingTauH2(n::RngIntElt) -> GrpPermElt
  {For n ge 2, returns tau identifying 2^n sheets to 2^(n-1) sheets}
  assert n gt 1;
  S := Sym(2^n);
  tau := Id(S);
  for i in [1..2^(n-1)] do
    tau := tau*S!(i,i+2^(n-1));
  end for;
  return tau;
end intrinsic;

// TODO
/*
intrinsic SolvableAboveH2(s::SolvableDBObject) -> SeqEnum[SolvableDBObject]
  {Given a solvableDBobj with monodromy G, find all central ZZ/2ZZ extensions of G (call such an extension Gt) and return a list of solvableDBobjects above s.}
  G := s`SolvableDBMonodromyGroup;
  Gts := [];
  // FIXME
  for i := 1 to #pass do
    // list0, list1, list_oo, all, possible, justramified, unramified, covers := PossibleGaloisCoveringPermutationTriples(pass[i] : return_everything := true);
    list0, list1, list_oo, all, possible, justramified, unramified, covers := PossibleGaloisCoveringPermutationTriplesRedux(pass[i] : return_everything := true);
    sorted_covers := SolvablePassportSort(covers cat unramified);
    // assert #unramified := &+[#sorted_unramified[i] : i in [1..#sorted_unramified]];
    // assert #ramified := &+[#sorted_ramified[i] : i in [1..#sorted_ramified]];
    if #sorted_covers eq 0 then // if there are no covers
      s`SolvableDBParents := [ "None" ]; // record that we checked for parents
    else
      for pass in sorted_covers do
        t := SolvableDBExample(pass);
        // t needs some graph information to merge
        t`SolvableDBChildren := [Sprintf("%o", s`SolvableDBName)]; // t should have s as a child
        t`SolvableDBPathToPP1 := s`SolvableDBPathToPP1; // start path to t with s path
        Append(~t`SolvableDBPathToPP1, t`SolvableDBName); // t is the end of path to t
        t, is_new := SolvableDBMerge(t); // merge t with the database
        if is_new then // t is new and merged with database
          // update parents of s
          if not assigned s`SolvableDBParents then
            s`SolvableDBParents := []; // initialize if not assigned
          end if;
          // s should have t as a parent
          Append(~s`SolvableDBParents, Sprintf("%o", t`SolvableDBName));
          SolvableDBWriteObject(s);
          // assert t has s as a child
          assert s`SolvableDBName in t`SolvableDBChildren;
          Append(~new_covers, t);
        end if;
      end for;
    end if;
  end for;
  return new_covers;
end intrinsic;
*/

// TODO
/*
intrinsic SolvableLevelH2(l::RngIntElt) -> Any
  {multiple calls to SolvableAboveH2 so that we can update parents and children accordingly.}
  if IsEven(l) and #Factorization(l) eq 1 then
    l_below := l div 2;
    filenames_below := SolvableDBFilenames(l_below);
    if #filenames_below eq 0 then
      error "we have not computed far enough to compute to this level yet!";
    else
      // make a bunch of files at level l by calling SolvableAbove a level below
      for name in filenames_below do
        s := SolvableDBAccessEntry(name);
        SolvableAbove(s);
      end for;
      return Sprintf("SolvableDB computed up to level %o\n", l);
    end if;
  else
    error "level is not valid";
  end if;
end intrinsic;
*/

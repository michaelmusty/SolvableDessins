intrinsic SolvableMapSanityCheck(s::SolvableDBObject : lax := false) -> BoolElt
  {BelyiMapSanityCheck...solvableified.}
  if assigned s`SolvableDBGaloisOrbit and assigned s`SolvableDBBelyiCurve and assigned s`SolvableDBBelyiMap then
    pass := s`SolvableDBGaloisOrbit;
    curve := s`SolvableDBBelyiCurve;
    map := s`SolvableDBBelyiMap;
    for i := 1 to #pass do
      if not BelyiMapSanityCheck(pass[i], curve, map : lax := lax) then
        vprintf Solvable: "Solvable Sanity Failed:\n";
        vprintf Solvable: "sigma = \n%o.\n", pass[i];
        supp, mult := Support(Divisor(map));
        vprintf Solvable: "supp(phi) = \n%o\n%o.\n", supp, mult;
        supp1, mult1 := Support(Divisor(map-1));
        vprintf Solvable: "supp(phi-1) = \n%o\n%o.\n", supp1, mult1;
        return false;
      end if;
    end for;
    // if we make it out of the loop return true
    return true;
  else
    return false;
  end if;
end intrinsic;

// TODO local sanity check

intrinsic SolvableIsUnramified(s::SolvableDBObject) -> BoolElt, MonStgElt
  {checks if s is unramified over any of its children and returns a bool and the child.}
  // fixed error when reading in PP1 if s has degree 2
  if s`SolvableDBDegree eq 2 then
    return false, "None";
  else
    assert assigned s`SolvableDBChildren;
    assert #s`SolvableDBChildren gt 0;
    children := s`SolvableDBChildren;
    sABC := s`SolvableDBABC;
    for i := 1 to #children do
      t := SolvableDBAccessEntry(children[i] cat ".m");
      tABC := t`SolvableDBABC;
      if sABC eq tABC then
        return true, children[i];
      end if;
    end for;
    // if we make it out of the loop then s is not ramified over any children
    return false, "None";
  end if;
end intrinsic;

intrinsic SolvableIsRamifiedAtEveryLevel(s::SolvableDBObject) -> BoolElt
  {true if s is ramified (at at least one point) at every intermediate level.}
  if s`SolvableDBDegree eq 2 then
    return true;
  else
    path := s`SolvableDBPathToPP1; // PP1, degree 2, degree 4, etc
    path_filenames := [];
    for i := #path to 2 by -1 do
      Append(~path_filenames, path[i] cat ".m");
    end for;
    unramified_bool := false;
    for i := 1 to #path_filenames-1 do
      top := SolvableDBAccessEntry(path_filenames[i]);
      bottom := SolvableDBAccessEntry(path_filenames[i+1]);
      topABC := top`SolvableDBABC;
      bottomABC := bottom`SolvableDBABC;
      if topABC eq bottomABC then
        unramified_bool := true;
      end if;
    end for;
    if unramified_bool then
      return false;
    else
      return true;
    end if;
  end if;
end intrinsic;

intrinsic SolvableBaseChange(s::SolvableDBObject, K::FldNum) -> SolvableDBObject
  {Extend base field of object to K.}
  // curve
  X := s`SolvableDBBelyiCurve;
  X := BaseChange(X, K);
  vars := VarSeq("x", 1, Rank(Generic(Ideal(X))));
  AssigneNames(~X, vars);
  s`SolvableDBBelyiCurve := X;
  // map
  map := s`SolvableDBBelyiMap;
  KX := FunctionField(X);
  AssignNames(~KX, vars);
  phi := eval Sprintf("phi := KX!(%o); return phi;", map);
  s`SolvableDBBelyiMap := phi;
  // sanity and return
  assert SolvableMapSanityCheck(s);
  return s;
end intrinsic;

intrinsic SolvableCheckResidueFields(D::DivCrvElt) -> BoolElt, Any
  {Computes the residue fields at places in support of D. Returns false, FldRat if these are all trivial. Returns true, Compositum of all residue fields if any residue fields are not trivial.}
  supp := Support(D);
  assert #supp gt 0;
  fields := [* *];
  non_trivial := false;
  for pt in supp do
    field := AbsoluteField(ResidueClassField(FunctionFieldPlace(pt)));
    if Degree(field) gt 1 then
      non_trivial := true;
    end if;
    Append(~fields, field);
  end for;
  if non_trivial eq false then
    return false, Rationals();
  else
    return_field := Rationals();
    for i := 1 to #fields do
      return_field := Compositum(return_field, fields[i]);
    end for;
    return true, AbsoluteField(return_field);
  end if;
end intrinsic;

intrinsic SolvableSetToDivisor(set::SetEnum[PlcCrvElt]) -> DivCrvElt
  {Given a set of places, return the divisor.}
  DivX := Parent(Divisor(Random(set)));
  D := DivX!0;
  for pt in set do
    D := D+Divisor(pt);
  end for;
  return D;
end intrinsic;

intrinsic SolvableRamificationDivisorUsingAllPoints(D::DivCrvElt) -> BoolElt, DivCrvElt
  {Attempt to find 1 dimensional Lspace using all points in D.}
  vprintf Solvable: "#supp(Divisor) = %o\n", #Support(D);
  worked := false;
  supp := Support(D);
  suppset := SequenceToSet(supp);
  subs := Subsets(suppset);
  for sub in subs do
    if #sub ne 0 and #sub ne #suppset then
      pos := SolvableSetToDivisor(sub);
      neg := SolvableSetToDivisor(suppset diff sub);
      supp, mult := Support(pos-neg);
      vprintf Solvable: "Checking divisor:\n%o\n%o\n", supp, mult;
      if Dimension(RiemannRochSpace(pos-neg)) eq 1 then
        vprintf Solvable: "It worked!\n";
        return true, pos-neg;
      else
        vprintf Solvable: "Didn't work >_<.\n";
      end if;
    end if;
  end for;
  return false, Parent(D)!0;
end intrinsic;

intrinsic SolvableDimensionOneLspacesUsingAllPoints(D::DivCrvElt) -> BoolElt, List
  {Find all 1 dimensional Lspace using all points in D. Return true if at least one such divisor.}
  supp := Support(D);
  suppset := SequenceToSet(supp);
  subs := Subsets(suppset);
  dimension_one_spaces := [* *];
  for sub in subs do
    if #sub ne 0 and #sub ne #suppset then
      pos := SolvableSetToDivisor(sub);
      neg := SolvableSetToDivisor(suppset diff sub);
      supp, mult := Support(pos-neg);
      vprintf Solvable: "Checking divisor:\n%o\n%o\n", supp, mult;
      if Dimension(RiemannRochSpace(pos-neg)) eq 1 then
        vprintf Solvable: "It worked!\n";
        Append(~dimension_one_spaces, pos-neg);
      else
        vprintf Solvable: "Didn't work >_<.\n";
      end if;
    end if;
  end for;
  if #dimension_one_spaces gt 0 then
    return true, dimension_one_spaces;
  else
    return false, [* Parent(D)!0 *];
  end if;
end intrinsic;

intrinsic SolvableRamificationToDivisor(ram::SeqEnum[BoolElt], Ds::List) -> DivCrvElt
  {Given ramification data and [D0, D1, Doo], return corresponding divisor.}
  assert #ram eq 3;
  ram0, ram1, ramoo := Explode(ram);
  assert #Ds eq 3;
  D0, D1, Doo := Explode(Ds);
  if ram0 then
    if ram1 then
      if ramoo then
        // 0,1,oo ramified
        return D0+D1+Doo;
      else
        // 0,1 ramified
        return D0+D1;
      end if;
    else
      if ramoo then
        // 0,oo ramified
        return D0+Doo;
      else
        // 0 ramified
        return D0;
      end if;
    end if;
  else
    if ram1 then
      if ramoo then
        // 1,oo ramified
        return D1+Doo;
      else
        // 1 ramified
        return D1;
      end if;
    else
      if ramoo then
        // oo ramified
        return Doo;
      else
        // unramified
        error "unramified...what?";
      end if;
    end if;
  end if;
end intrinsic;

intrinsic ExtractRoot(Y::Crv, f::FldFunFracSchElt, m::RngIntElt) -> Crv
  {Given a curve Y, and f in KY the function field of Y, return a new curve X with function field KX where KX = KY(mthroot(f)).}
  // assertions
    assert IsAffine(Y);
    KY := FunctionField(Y);
    assert Parent(f) eq KY;
  // ambient, ideal, polynomial ring of Y
    IY := Ideal(Y);
    PY := Generic(IY);
    AAY := Ambient(Y);
  // polynomial ring and ideal upstairs
    IYext, mp := VariableExtension(IY, 1, false); // mp: PY -> PX
    PX := Codomain(mp);
    assert PX eq Generic(IYext);
    AssignNames(~PX, VarSeq("x", 1, Rank(PX)));
  // map numerator and denominator of f into PX
    numer := mp(Numerator(f, Y));
    denom := mp(Denominator(f, Y));
  // basis of new ideal
    basis := Basis(IYext);
    new_equation := denom*PX.Rank(PX)^2-numer;
    Append(~basis, new_equation);
    IX := ideal< PX | basis >;
    S := Saturation(IX, numer); // saturate at numerator
    assert IsPrime(S); // otherwise saturation didn't work
  // new ambient
    AAX := AffineSpace(PX);
  // make curve by saturating at numerator
    X := Curve(AAX, S);
    return X;
end intrinsic;

intrinsic SolvableAssignRamification(s::SolvableDBObject) -> SolvableDBObject
  {assigns [ram0, ram1, ramoo] to s.}
  t := Child(s);
  abc_below := t`SolvableDBABC;
  abc := s`SolvableDBABC;
  // ramification above 0
    if abc_below[1] eq abc[1] then
      ram0 := false;
    else
      assert abc[1] eq 2*abc_below[1];
      ram0 := true;
    end if;
  // ramification above 1
    if abc_below[2] eq abc[2] then
      ram1 := false;
    else
      assert abc[2] eq 2*abc_below[2];
      ram1 := true;
    end if;
  // ramification above oo
    if abc_below[3] eq abc[3] then
      ramoo := false;
    else
      assert abc[3] eq 2*abc_below[3];
      ramoo := true;
    end if;
  // assign to s and return s
  s`SolvableDBRamification := [ram0, ram1, ramoo];
  return s;
end intrinsic;

intrinsic SolvableAssignResidueFieldsAndDivisors(s::SolvableDBObject) -> SolvableDBObject
  {assigns F0, F1, Foo to s.}
  assert assigned s`SolvableDBRamification;
  t := Child(s);
  ram0, ram1, ramoo := Explode(s`SolvableDBRamification);
  X_below := t`SolvableDBBelyiCurve;
  phi_below := t`SolvableDBBelyiMap;
  DivX_below := DivisorGroup(X_below);
  // ram0
    if ram0 then
      D0 := Numerator(Divisor(phi_below));
      _, F0 := SolvableCheckResidueFields(D0);
      vprintf Solvable: "D0 divisor:\n";
      supp0, mult0 := Support(D0);
      vprintf Solvable: "%o\n%o\n", supp0, mult0;
      vprintf Solvable: "D0 degree of residue fields: %o\n", Degree(F0);
      vprintf Solvable: "#supp(D0) before base change = %o.\n", #Support(D0);
    else
      vprintf Solvable: "D0 nothing to do.\n";
      D0 := DivX_below!0;
      F0 := Rationals();
    end if;
  // ram1
    if ram1 then
      D1 := Numerator(Divisor(phi_below-1));
      _, F1 := SolvableCheckResidueFields(D1);
      vprintf Solvable: "D1 divisor:\n";
      supp1, mult1 := Support(D1);
      vprintf Solvable: "%o\n%o\n", supp1, mult1;
      vprintf Solvable: "D1 degree of residue fields: %o\n", Degree(F1);
      vprintf Solvable: "#supp(D1) before base change = %o.\n", #Support(D1);
    else
      vprintf Solvable: "D1 nothing to do.\n";
      D1 := DivX_below!0;
      F1 := Rationals();
    end if;
  // ramoo
    if ramoo then
      Doo := Denominator(Divisor(phi_below));
      _, Foo := SolvableCheckResidueFields(Doo);
      vprintf Solvable: "Doo divisor:\n";
      suppoo, multoo := Support(Doo);
      vprintf Solvable: "%o\n%o\n", suppoo, multoo;
      vprintf Solvable: "Doo degree of residue fields: %o\n", Degree(Foo);
      vprintf Solvable: "#supp(Doo) before base change = %o.\n", #Support(Doo);
    else
      vprintf Solvable: "Doo nothing to do.\n";
      Doo := DivX_below!0;
      Foo := Rationals();
    end if;
  // assign and return
    vprintf Solvable: "ResidueFields:\n";
    vprintf Solvable: "F0 = %o\n", F0;
    vprintf Solvable: "F1 = %o\n", F1;
    vprintf Solvable: "Foo = %o\n", Foo;
    s`SolvableDBResidueField0 := F0;
    s`SolvableDBResidueField1 := F1;
    s`SolvableDBResidueFieldoo := Foo;
    s`SolvableDBDivisor0 := D0;
    s`SolvableDBDivisor1 := D1;
    s`SolvableDBDivisoroo := Doo;
    return s;
end intrinsic;

intrinsic SolvableBelyiMap(s::SolvableDBObject) -> SolvableDBObject
  {}
  // if s is unramified then stop and return s
    isunram := not SolvableIsRamifiedAtEveryLevel(s);
    if isunram then
      name := s`SolvableDBName;
      error Sprintf("%o is unramified at some level, no method to compute unramified covers (currently).\n", name);
    end if;
  // assertions about child of s
    vprintf Solvable: "So you want to compute a SolvableBelyiMap? Checking basic assertions.\n";
    time_start := Cputime();
    t := Child(s);
    assert SolvableMapSanityCheck(t);
    time_end := Cputime();
    vprintf Solvable: "Done. That took %o seconds.\n", time_end-time_start;
  // [ram0, ram1, ramoo] a sequence of bools
    vprintf Solvable: "Determining ramification:\n";
    abc_below := t`SolvableDBABC;
    abc := s`SolvableDBABC;
    s := SolvableAssignRamification(s);
    ram0, ram1, ramoo := Explode(s`SolvableDBRamification);
    vprintf Solvable: "ABC before = %o.\n", abc_below;
    vprintf Solvable: "ramification = %o.\n", [ram0, ram1, ramoo];
    vprintf Solvable: "ABC after = %o.\n", abc;
  // assign residue fields F0, F1, Foo, and divisors D0, D1, Doo
    vprintf Solvable : "Assign residue fields to s...";
    t0 := Cputime();
    s := SolvableAssignResidueFieldsAndDivisors(s);
    F0 := s`SolvableDBResidueField0;
    F1 := s`SolvableDBResidueField1;
    Foo := s`SolvableDBResidueFieldoo;
    D0 := s`SolvableDBDivisor0;
    D1 := s`SolvableDBDivisor1;
    Doo := s`SolvableDBDivisoroo;
    t1 := Cputime();
    vprintf Solvable : "done. %o seconds.\n", t1-t0;
  // check if base change is needed
      vprintf Solvable: "Try to find dimension one L-spaces before base change:\n";
      Dinitial := SolvableRamificationToDivisor([ram0, ram1, ramoo], [*D0, D1, Doo*]); // divisor without basechange
      vprintf Solvable : "Initial ramification divisor computed. Do we need to base change?\n";
      vprintf Solvable : "First try initial ramification divisor.\n";
      vprintf Solvable : "#supp(Divisor) = %o\n", #Support(Dinitial);
      vprintf Solvable : "Trying all combinations...";
      t0 := Cputime();
      // worked_before_basechange, D := SolvableRamificationDivisorUsingAllPoints(Dinitial);
      worked_before_basechange, all_dim_one_before := SolvableDimensionOneLspacesUsingAllPoints(Dinitial);
      s`SolvableDBDimensionOneLspacesBeforeBaseChange := all_dim_one_before;
      t1 := Cputime();
      vprintf Solvable : "done. %o seconds.\n", t1-t0;
    // update t with base change if necessary
    // NOTE this does not update t in the database, just to be used for s later
      if worked_before_basechange then
        vprintf Solvable: "No need to BaseChange.\n";
      else
        vprintf Solvable: "Base changing...\n";
        vprintf Solvable: "Updating curve base field:\n";
        F := BaseField(t`SolvableDBBelyiCurve);
        vprintf Solvable: "Degree of current base field = %o\n", Degree(F);
        newF := Compositum(F, F0);
        vprintf Solvable: "Degree with F0 = %o.\n", Degree(newF);
        newF := Compositum(newF, F1);
        vprintf Solvable: "Degree with F1 = %o.\n", Degree(newF);
        newF := Compositum(newF, Foo);
        vprintf Solvable: "Degree with Foo = %o.\n", Degree(newF);
        t := SolvableBaseChange(t, newF); // TODO update this function
        vprintf Solvable: "OK done. Here is the new field:\n%o\n", newF;
        // assert t`SolvableDBCurveBaseFieldList[#t`SolvableDBCurveBaseFieldList] eq newF;
        vprintf Solvable: "Now updating divisors D0, D1, Doo.\n";
        // update D0, D1, Doo after base change
        X_below := t`SolvableDBBelyiCurve;
        phi_below := t`SolvableDBBelyiMap;
        DivX_below := DivisorGroup(X_below);
        if ram0 then
          D0 := Numerator(Divisor(phi_below));
          vprintf Solvable: "#supp(D0) after base change = %o.\n", #Support(D0);
        else
          D0 := DivX_below!0;
        end if;
        if ram1 then
          D1 := Numerator(Divisor(phi_below-1));
          vprintf Solvable: "#supp(D1) after base change = %o.\n", #Support(D1);
        else
          D1 := DivX_below!0;
        end if;
        if ramoo then
          Doo := Denominator(Divisor(phi_below));
          vprintf Solvable: "#supp(Doo) after base change = %o.\n", #Support(Doo);
        else
          Doo := DivX_below!0;
        end if;
        // make ramification divisor after BaseChange
        vprintf Solvable: "Finding Ramification Divisor After BaseChange:\n";
        time_start := Cputime();
        // worked_after_basechange, D := SolvableRamificationDivisor([ram0, ram1, ramoo], [*D0, D1, Doo*]);
        Dinitial := SolvableRamificationToDivisor([ram0, ram1, ramoo], [*D0, D1, Doo*]);
        worked_after_basechange, D := SolvableRamificationDivisorUsingAllPoints(Dinitial);
        time_end := Cputime();
        if worked_after_basechange then
          vprintf Solvable: "OK done! That took %o seconds.\n", time_end-time_start;
        else
          error "base change didn't help us find dimension 1 Lspace :(";
        end if;
      end if;
  // RiemannRoch
    vprintf Solvable: "Applying RiemannRoch to following divisor:\n";
    supp, mult := Support(D);
    vprintf Solvable: "%o\n%o\n", supp, mult;
    LD, mpLDtoKX := RiemannRochSpace(D);
    assert Dimension(LD) eq 1;
    f := mpLDtoKX(LD.1);
    denom := Denominator(f, X_below);
    numer := Numerator(f, X_below);
    assert Parent(denom) eq Parent(numer);
    vprintf Solvable: "Parent(f) =\n%o\n", Parent(f);
    vprintf Solvable: "f = \n%o\n", f;
    vprintf Solvable: "Numerator(f) = %o.\n", numer;
    vprintf Solvable: "Denominator(f) = %o.\n", denom;
  // make the curve (brutal) using primary decomposition or (less brutal) use saturation
  // TODO have X_below and f in KX_below, extract root
    vprintf Solvable : "Extracting root to make new curve...";
    t0 := Cputime();
    X := ExtractRoot(X_below, f, 2); // TODO make this function
    t1 := Cputime();
    vprintf Solvable : "done. %o seconds.\n", t1-t0;
    vprintf Solvable : "Making new Belyi map...";
    KX := FunctionField(X);
    phi := KX.1;
    vprintf Solvable : "done.\n";
  // assertions
    vprintf Solvable : "Checking genus of curve...";
    assert s`SolvableDBGenus eq Genus(X);
    vprintf Solvable : "done.\n";
  // assign information to s and return s
    s`SolvableDBBelyiCurve := X;
    s`SolvableDBBelyiMap := phi;
    return s;
end intrinsic;

intrinsic SolvableBelyiMaps(d::RngIntElt) -> Any
  {Multiple calls to SolvableBelyiMapOptimized (singular) and returns the errors.}
  f := SolvableDBFilenames(d);
  errors := [];
  for i := 1 to #f do
    s := SolvableDBAccessEntry(f[i]);
    try
      time_start := Cputime();
      if (not SolvableIsUnramified(s)) and (not (assigned s`SolvableDBBelyiCurve)) then
        assert not assigned s`SolvableDBBelyiMap;
        s := SolvableBelyiMap(s);
        vprintf Solvable : "%o sanity check...", s`SolvableDBName;
        if SolvableMapSanityCheck(s) then
          vprintf Solvable : "done.\n";
          SolvableDBWriteObject(s);
        end if;
      end if;
      time_end := Cputime();
      vprintf Solvable : "%o time: %o\n", s`SolvableDBName, time_end-time_start;
    catch e
      print e;
      Append(~errors, e);
    end try;
  end for;
  return errors;
end intrinsic;

intrinsic IsoText(var::MonStgElt, lower::RngIntElt, upper::RngIntElt) -> MonStgElt
  {returns text "var.lower, var.lower+1, ..., var.upper-1, var.upper".}
  assert upper ge lower;
  var_text := "";
  if upper eq lower then
    var_text *:= Sprintf("%o.%o", var, lower);
  else
    for i := lower to upper-1 by 1 do
      var_text *:= Sprintf("%o.%o, ", var, i);
    end for;
    var_text *:= Sprintf("%o.%o", var, upper);
  end if;
  return var_text;
end intrinsic;

// update 2018
intrinsic SolvableLowDegreeModel(s::SolvableDBObject) -> Any
  {Naively try to reduce the degree of the BelyiCurve.}
  vprintf Solvable : "%o LowDegreeAttempt :\n", s`SolvableDBName;
  curve_assigned := assigned s`SolvableDBBelyiCurve;
  map_assigned := assigned s`SolvableDBBelyiMap;
  if curve_assigned and map_assigned then
    // make before and after objects
      before := SolvableDBObjectInitialize();
      after := SolvableDBObjectInitialize();
      attrs := GetAttributes(Type(s));
      for attr in attrs do
        if assigned s``attr then
          before``attr := s``attr;
          after``attr := s``attr;
        end if;
      end for;
    // setup for various cases
      vprintf Solvable : "  Belyi curve and map assigned.\n";
      X := before`SolvableDBBelyiCurve;
      assert IsAffine(X);
      X_proj := ProjectiveClosure(X);
      f := before`SolvableDBBelyiMap;
      degree_start := Degree(X_proj);
      vprintf Solvable : "  Degree of Belyi curve = %o.\n", degree_start;
      vprintf Solvable : "  Checking Canonical map...";
      t0 := Cputime();
      g, is_low_genus_or_hyp, mp := GenusAndCanonicalMap(X); // better to take projective closure?
      t1 := Cputime();
      vprintf Solvable : "done. %o seconds.\n", t1-t0;
    // cases
      if IsHyperelliptic(X) then
        assert is_low_genus_or_hyp;
        // computing hyperelliptic model
          vprintf Solvable : "  Curve is hyperelliptic.\n";
          vprintf Solvable : "  asserting IsHyperelliptic...";
          t0 := Cputime();
          hyp_bool, hyp_H, hyp_mp := IsHyperelliptic(X);
          t1 := Cputime();
          vprintf Solvable : "done. %o seconds.\n", t1-t0;
          vprintf Solvable : "  asserting IsGeometricallyHyperelliptic...";
          t0 := Cputime();
          geom_bool, geom_H, geom_mp := IsGeometricallyHyperelliptic(X);
          t1 := Cputime();
          vprintf Solvable : "done. %o seconds.\n", t1-t0;
          vprintf Solvable : "  Degree of new Belyi curve = %o.\n", Degree(hyp_H);
        // make new Belyi map, curve, and base field, assign to after object
          g := Pushforward(hyp_mp, f);
          X<x1, x2, x3> := hyp_H;
          KX<x1, x2> := FunctionField(X);
          assert KX eq Parent(g);
          K := BaseField(X);
          if Type(K) eq FldNum then
            K<nu> := BaseField(X);
          end if;
          after`SolvableDBBelyiCurve := X;
          after`SolvableDBBelyiMap := g; // not necessarily KX.1
        // bookkeeping and return
          // sanity checks
          vprintf Solvable : "  Sanity checking...";
          t0 := Cputime();
          assert SolvableMapSanityCheck(before);
          assert SolvableMapSanityCheck(after);
          t1 := Cputime();
          vprintf Solvable : "done. %o seconds.\n", t1-t0;
        return before, after;
      else // g > 1 and curve is not hyperelliptic
        // computing new model
          vprintf Solvable : "  Curve is not hyperelliptic.\n";
          vprintf Solvable : "  Projecting to PP3...";
          t0 := Cputime();
          C, mp := EmbedPlaneCurveInP3(X); // the scheme is the codomain of mp
          assert IsProjective(Ambient(C));
          assert Curve(C) eq C;
          /*
          dim := Dimension(Ambient(C))+1; // projective
          Sctext := IsoText("Sc", 1, dim);
          Ctext := IsoText("C", 1, dim);
          id := eval Sprintf("id := iso< Sc -> C | [%o], [%o] >; return id;", Sctext, Ctext);
          */
          fix := map< X_proj -> C | DefiningEquations(mp) >;
          g := Pushforward(fix, f);
          t1 := Cputime();
          vprintf Solvable : "done. %o seconds.\n", t1-t0;
          C := AffinePatch(C, 1); // TODO not pick blindly?
          I := Ideal(C);
          P := Generic(I);
          num_vars := Rank(P);
          Ceval := C;
          C := eval Sprintf("C<%o> := Ceval; return C;", VarText("x", 1, num_vars));
          KC := eval Sprintf("KC<%o> := FunctionField(C); return KC;", VarText("x", 1, num_vars-1));
          assert Parent(g) eq KC;
          K := BaseField(C);
          if ISA(Type(K), FldNum) then
            K<nu> := BaseField(C);
          end if;
          after`SolvableDBBelyiCurve := C;
          after`SolvableDBBelyiMap := g;
          assert Parent(g) eq KC;
          if not g eq KC.1 then
            vprintf Solvable : "  WARNING! new Belyi map is no longer KX.1\n";
          end if;
          vprintf Solvable : "  Degree of new model = %o.\n", Degree(C);
        // bookkeeping and return
          // sanity checks
          assert Parent(g) eq FunctionField(C);
          vprintf Solvable : "  Sanity checking...";
          t0 := Cputime();
          assert SolvableMapSanityCheck(before);
          assert SolvableMapSanityCheck(after);
          t1 := Cputime();
          vprintf Solvable : "done. %o seconds.\n", t1-t0;
          return before, after;
      end if;
  else
    vprintf Solvable : "Belyi map (or curve) is not assigned.\n";
    return s;
  end if;
end intrinsic;

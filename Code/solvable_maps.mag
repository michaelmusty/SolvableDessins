intrinsic SolvableMapSanityCheck(s::SolvableDBObject : lax := false) -> BoolElt
  {BelyiMapSanityCheck...solvableified.}
  if assigned s`SolvableDBGaloisOrbit and assigned s`SolvableDBBelyiCurve and assigned s`SolvableDBBelyiMap then
    pass := s`SolvableDBGaloisOrbit;
    curve := s`SolvableDBBelyiCurve;
    map := s`SolvableDBBelyiMap;
    for i := 1 to #pass do
      if not BelyiMapSanityCheck(pass[i], curve, map : lax := lax) then
        vprintf Solvable: "Solvable Sanity Failed:\n";
        vprintf Solvable: "sigma = \n%o.\n", pass[i];
        supp, mult := Support(Divisor(map));
        vprintf Solvable: "supp(phi) = \n%o\n%o.\n", supp, mult;
        supp1, mult1 := Support(Divisor(map-1));
        vprintf Solvable: "supp(phi-1) = \n%o\n%o.\n", supp1, mult1;
        return false;
      end if;
    end for;
    // if we make it out of the loop return true
    return true;
  else
    return false;
  end if;
end intrinsic;

intrinsic SolvableIsUnramified(s::SolvableDBObject) -> BoolElt, MonStgElt
  {checks if s is unramified over any of its children and returns a bool and the child.}
  // fixed error when reading in PP1 if s has degree 2
  if s`SolvableDBDegree eq 2 then
    return false, "None";
  else
    assert assigned s`SolvableDBChildren;
    assert #s`SolvableDBChildren gt 0;
    children := s`SolvableDBChildren;
    sABC := s`SolvableDBABC;
    for i := 1 to #children do
      t := SolvableDBAccessEntry(children[i] cat ".m");
      tABC := t`SolvableDBABC;
      if sABC eq tABC then
        return true, children[i];
      end if;
    end for;
    // if we make it out of the loop then s is not ramified over any children
    return false, "None";
  end if;
end intrinsic;

intrinsic SolvableBaseChange(s::SolvableDBObject, K::FldNum) -> SolvableDBObject
  {Extend base field of object to K.}
  assert SolvableMapSanityCheck(s);
  l := s`SolvableDBLevel;
  // base field
  Remove(~s`SolvableDBCurveBaseFieldList, #s`SolvableDBCurveBaseFieldList);
  Append(~s`SolvableDBCurveBaseFieldList, K);
  // polynomial ring
  PX := s`SolvableDBCurvePolynomialRingList[#s`SolvableDBCurvePolynomialRingList];
  PX := ChangeRing(PX, K);
  Remove(~s`SolvableDBCurvePolynomialRingList, #s`SolvableDBCurvePolynomialRingList);
  Append(~s`SolvableDBCurvePolynomialRingList, PX);
  // ambient
  Remove(~s`SolvableDBCurveAmbientList, #s`SolvableDBCurveAmbientList);
  AA := AffineSpace(PX);
  Append(~s`SolvableDBCurveAmbientList, AA);
  // ideal
  I := s`SolvableDBCurveIdealList[#s`SolvableDBCurveIdealList];
  Remove(~s`SolvableDBCurveIdealList, #s`SolvableDBCurveIdealList);
  Append(~s`SolvableDBCurveIdealList, ideal< PX | Basis(I) >);
  // curve list
  X := s`SolvableDBCurveList[#s`SolvableDBCurveList];
  Remove(~s`SolvableDBCurveList, #s`SolvableDBCurveList);
  Append(~s`SolvableDBCurveList, BaseChange(X, K));
  // belyi curve
  curve := s`SolvableDBBelyiCurve;
  assert curve eq X;
  s`SolvableDBBelyiCurve := BaseChange(curve, K);
  // TODO assertion that works?
  // assert IsIsomorphic(s`SolvableDBBelyiCurve, BaseChange(X, K));
  // belyi map
  map := s`SolvableDBBelyiMap;
  KX := FunctionField(X);
  assert map eq KX.1;
  X := BaseChange(X, K);
  KX := FunctionField(X);
  s`SolvableDBBelyiMap := KX.1;
  // assert
  assert SolvableMapSanityCheck(s);
  // return
  return s;
end intrinsic;

intrinsic SolvableCheckResidueFields(D::DivCrvElt) -> BoolElt, Any
  {Computes the residue fields at places in support of D. Returns false, FldRat if these are all trivial. Returns true, Compositum of all residue fields if any residue fields are not trivial.}
  supp := Support(D);
  assert #supp gt 0;
  fields := [* *];
  non_trivial := false;
  for pt in supp do
    field := AbsoluteField(ResidueClassField(FunctionFieldPlace(pt)));
    if Degree(field) gt 1 then
      non_trivial := true;
    end if;
    Append(~fields, field);
  end for;
  if non_trivial eq false then
    return false, Rationals();
  else
    return_field := Rationals();
    for i := 1 to #fields do
      return_field := Compositum(return_field, fields[i]);
    end for;
    return true, AbsoluteField(return_field);
  end if;
end intrinsic;

intrinsic SolvableSetToDivisor(set::SetEnum[PlcCrvElt]) -> DivCrvElt
  {Given a set of places, return the divisor.}
  DivX := Parent(Divisor(Random(set)));
  D := DivX!0;
  for pt in set do
    D := D+Divisor(pt);
  end for;
  return D;
end intrinsic;

intrinsic SolvableRamificationDivisorUsingAllPoints(D::DivCrvElt) -> BoolElt, DivCrvElt
  {Attempt to find 1 dimensional Lspace using all points in D.}
  vprintf Solvable: "#supp(Divisor) = %o\n", #Support(D);
  worked := false;
  supp := Support(D);
  suppset := SequenceToSet(supp);
  subs := Subsets(suppset);
  for sub in subs do
    if #sub ne 0 and #sub ne #suppset then
      pos := SolvableSetToDivisor(sub);
      neg := SolvableSetToDivisor(suppset diff sub);
      supp, mult := Support(pos-neg);
      vprintf Solvable: "Checking divisor:\n%o\n%o\n", supp, mult;
      if Dimension(RiemannRochSpace(pos-neg)) eq 1 then
        vprintf Solvable: "It worked!\n";
        return true, pos-neg;
      else
        vprintf Solvable: "Didn't work >_<.\n";
      end if;
    end if;
  end for;
  return false, Parent(D)!0;
end intrinsic;

/*
intrinsic SolvableRamificationDivisor(ram::SeqEnum[BoolElt], Ds::List) -> BoolElt, DivCrvElt
  {Attempt to find D with 1 dimensional Lspace. Bool is to tell if successful.}
  vprintf Solvable: "Trying to find 1 dimensional Lspace:\n";
  assert #ram eq 3;
  ram0, ram1, ramoo := Explode(ram);
  assert #Ds eq 3;
  D0, D1, Doo := Explode(Ds);
  if ram0 then
    if ram1 then
      if ramoo then
        // 0,1,oo ramified
        if Dimension(RiemannRochSpace(D0+D1+Doo)) eq 1 then
          return true, D0+D1+Doo;
        elif Dimension(RiemannRochSpace(-D0+D1+Doo)) eq 1 then
          return true, -D0+D1+Doo;
        elif Dimension(RiemannRochSpace(D0-D1+Doo)) eq 1 then
          return true, D0-D1+Doo;
        elif Dimension(RiemannRochSpace(D0+D1-Doo)) eq 1 then
          return true, D0+D1-Doo;
        elif Dimension(RiemannRochSpace(D0-D1-Doo)) eq 1 then
          return true, D0-D1-Doo;
        elif Dimension(RiemannRochSpace(-D0+D1-Doo)) eq 1 then
          return true, -D0+D1-Doo;
        elif Dimension(RiemannRochSpace(-D0-D1-Doo)) eq 1 then
          return true, -D0-D1+Doo;
        elif Dimension(RiemannRochSpace(-D0-D1-Doo)) eq 1 then
          return true, -D0-D1-Doo;
        else
          vprintf Solvable: "Naive methods failed...using ALL points...\n";
          worked, D := SolvableRamificationDivisorUsingAllPoints(D0+D1+Doo);
          if worked then
            vprintf Solvable: "OMG it worked!\n";
            return true, D;
          else
            return false, D;
          end if;
        end if;
      else
        // 0,1 ramified
        if Dimension(RiemannRochSpace(D0+D1)) eq 1 then
          return true, D0+D1;
        elif Dimension(RiemannRochSpace(-D0+D1)) eq 1 then
          return true, -D0+D1;
        elif Dimension(RiemannRochSpace(D0-D1)) eq 1 then
          return true, D0-D1;
        elif Dimension(RiemannRochSpace(-D0-D1)) eq 1 then
          return true, -D0-D1;
        else
          vprintf Solvable: "Naive methods failed...using ALL points...\n";
          worked, D := SolvableRamificationDivisorUsingAllPoints(D0+D1);
          if worked then
            vprintf Solvable: "OMG it worked!\n";
            return true, D;
          else
            return false, D;
          end if;
        end if;
      end if;
    else
      if ramoo then
        // 0,oo ramified
        if Dimension(RiemannRochSpace(D0+Doo)) eq 1 then
          return true, D0+Doo;
        elif Dimension(RiemannRochSpace(-D0+Doo)) eq 1 then
          return true, -D0+Doo;
        elif Dimension(RiemannRochSpace(D0-Doo)) eq 1 then
          return true, D0-Doo;
        elif Dimension(RiemannRochSpace(-D0-Doo)) eq 1 then
          return true, -D0-Doo;
        else
          vprintf Solvable: "Naive methods failed...using ALL points...\n";
          worked, D := SolvableRamificationDivisorUsingAllPoints(D0+Doo);
          if worked then
            vprintf Solvable: "OMG it worked!\n";
            return true, D;
          else
            return false, D;
          end if;
        end if;
      else
        // 0 ramified
        if Dimension(RiemannRochSpace(D0)) eq 1 then
          return true, D0;
        elif Dimension(RiemannRochSpace(-D0)) eq 1 then
          return true, -D0;
        else
          vprintf Solvable: "Naive methods failed...using ALL points...\n";
          worked, D := SolvableRamificationDivisorUsingAllPoints(D0);
          if worked then
            vprintf Solvable: "OMG it worked!\n";
            return true, D;
          else
            return false, D;
          end if;
        end if;
      end if;
    end if;
  else
    if ram1 then
      if ramoo then
        // 1,oo ramified
        if Dimension(RiemannRochSpace(D1+Doo)) eq 1 then
          return true, D1+Doo;
        elif Dimension(RiemannRochSpace(-D1+Doo)) eq 1 then
          return true, -D1+Doo;
        elif Dimension(RiemannRochSpace(D1-Doo)) eq 1 then
          return true, D1-Doo;
        elif Dimension(RiemannRochSpace(-D1-Doo)) eq 1 then
          return true, -D1-Doo;
        else
          vprintf Solvable: "Naive methods failed...using ALL points...\n";
          worked, D := SolvableRamificationDivisorUsingAllPoints(D1+Doo);
          if worked then
            vprintf Solvable: "OMG it worked!\n";
            return true, D;
          else
            return false, D;
          end if;
        end if;
      else
        // 1 ramified
        if Dimension(RiemannRochSpace(D1)) eq 1 then
          return true, D1;
        elif Dimension(RiemannRochSpace(-D1)) eq 1 then
          return true, -D1;
        else
          vprintf Solvable: "Naive methods failed...using ALL points...\n";
          worked, D := SolvableRamificationDivisorUsingAllPoints(D1);
          if worked then
            vprintf Solvable: "OMG it worked!\n";
            return true, D;
          else
            return false, D;
          end if;
        end if;
      end if;
    else
      if ramoo then
        // oo ramified
        if Dimension(RiemannRochSpace(Doo)) eq 1 then
          return true, Doo;
        elif Dimension(RiemannRochSpace(-Doo)) eq 1 then
          return true, -Doo;
        else
          vprintf Solvable: "Naive methods failed...using ALL points...\n";
          worked, D := SolvableRamificationDivisorUsingAllPoints(Doo);
          if worked then
            vprintf Solvable: "OMG it worked!\n";
            return true, D;
          else
            return false, D;
          end if;
        end if;
      else
        // unramified
        error "unramified...what?";
      end if;
    end if;
  end if;
end intrinsic;
*/

intrinsic SolvableRamificationToDivisor(ram::SeqEnum[BoolElt], Ds::List) -> DivCrvElt
  {Given ramification data and [D0, D1, Doo], return corresponding divisor.}
  assert #ram eq 3;
  ram0, ram1, ramoo := Explode(ram);
  assert #Ds eq 3;
  D0, D1, Doo := Explode(Ds);
  if ram0 then
    if ram1 then
      if ramoo then
        // 0,1,oo ramified
        return D0+D1+Doo;
      else
        // 0,1 ramified
        return D0+D1;
      end if;
    else
      if ramoo then
        // 0,oo ramified
        return D0+Doo;
      else
        // 0 ramified
        return D0;
      end if;
    end if;
  else
    if ram1 then
      if ramoo then
        // 1,oo ramified
        return D1+Doo;
      else
        // 1 ramified
        return D1;
      end if;
    else
      if ramoo then
        // oo ramified
        return Doo;
      else
        // unramified
        error "unramified...what?";
      end if;
    end if;
  end if;
end intrinsic;

intrinsic SolvableBelyiMap(s::SolvableDBObject : force_basechange := false, child_index := 1, manual_divisor := 0, primary_index := 0) -> SolvableDBObject
  {computes BelyiMap for s and returns s. Optional to input a divisor for RiemannRoch and or an index to choose which Ps to take in the primary decomposition.}
  // if s is unramified then stop and return s
    isunram, unramchild := SolvableIsUnramified(s);
    if isunram then
      vprintf Solvable: "%o is unramified over %o\n", s`SolvableDBName, unramchild;
      return s;
    end if;
  // assertions about child of s
    vprintf Solvable: "So you want to compute a SolvableBelyiMap? Checking basic assertions.\n";
    time_start := Cputime();
    assert assigned s`SolvableDBChildren;
    // assert #s`SolvableDBChildren ge 1;
    assert #s`SolvableDBChildren eq 1;
    assert child_index le #s`SolvableDBChildren;
    t := SolvableDBAccessEntry(s`SolvableDBChildren[child_index] cat ".m");
    if SolvableIsUnramified(t) then
      vprintf Solvable: "%o is unramified child of %o\n", t`SolvableDBName, s`SolvableDBName;
      return s;
    end if;
    assert SolvableMapSanityCheck(t);
    time_end := Cputime();
    vprintf Solvable: "Done. That took %o seconds.\n", time_end-time_start;
  // [ram0, ram1, ramoo] a sequence of bools
    vprintf Solvable: "Determining ramification:\n";
    abc_below := t`SolvableDBABC;
    abc := s`SolvableDBABC;
    vprintf Solvable: "ABC before = %o.\n", abc_below;
    // ramification above 0
      if abc_below[1] eq abc[1] then
        ram0 := false;
      else
        assert abc[1] eq 2*abc_below[1];
        ram0 := true;
      end if;
    // ramification above 1
      if abc_below[2] eq abc[2] then
        ram1 := false;
      else
        assert abc[2] eq 2*abc_below[2];
        ram1 := true;
      end if;
    // ramification above oo
      if abc_below[3] eq abc[3] then
        ramoo := false;
      else
        assert abc[3] eq 2*abc_below[3];
        ramoo := true;
      end if;
    vprintf Solvable: "ramification = %o.\n", [ram0, ram1, ramoo];
    vprintf Solvable: "ABC after = %o.\n", abc;
  // check if we need to extend base field using BelyiMap below
    vprintf Solvable: "Checking if we need to extend base field:\n";
    X_below := t`SolvableDBBelyiCurve;
    phi_below := t`SolvableDBBelyiMap;
    DivX_below := DivisorGroup(X_below);
    // ram0
    if ram0 then
      D0 := Numerator(Divisor(phi_below));
      _, F0 := SolvableCheckResidueFields(D0);
      vprintf Solvable: "D0 divisor:\n";
      supp0, mult0 := Support(D0);
      vprintf Solvable: "%o\n%o\n", supp0, mult0;
      vprintf Solvable: "D0 degree of residue fields: %o\n", Degree(F0);
      vprintf Solvable: "#supp(D0) before base change = %o.\n", #Support(D0);
    else
      vprintf Solvable: "D0 nothing to do.\n";
      D0 := DivX_below!0;
      F0 := Rationals();
    end if;
    // ram1
    if ram1 then
      D1 := Numerator(Divisor(phi_below-1));
      _, F1 := SolvableCheckResidueFields(D1);
      vprintf Solvable: "D1 divisor:\n";
      supp1, mult1 := Support(D1);
      vprintf Solvable: "%o\n%o\n", supp1, mult1;
      vprintf Solvable: "D1 degree of residue fields: %o\n", Degree(F1);
      vprintf Solvable: "#supp(D1) before base change = %o.\n", #Support(D1);
    else
      vprintf Solvable: "D1 nothing to do.\n";
      D1 := DivX_below!0;
      F1 := Rationals();
    end if;
    // ramoo
    if ramoo then
      Doo := Denominator(Divisor(phi_below));
      _, Foo := SolvableCheckResidueFields(Doo);
      vprintf Solvable: "Doo divisor:\n";
      suppoo, multoo := Support(Doo);
      vprintf Solvable: "%o\n%o\n", suppoo, multoo;
      vprintf Solvable: "Doo degree of residue fields: %o\n", Degree(Foo);
      vprintf Solvable: "#supp(Doo) before base change = %o.\n", #Support(Doo);
    else
      vprintf Solvable: "Doo nothing to do.\n";
      Doo := DivX_below!0;
      Foo := Rationals();
    end if;
    vprintf Solvable: "ResidueFields:\n";
    vprintf Solvable: "F0 = %o\n", F0;
    vprintf Solvable: "F1 = %o\n", F1;
    vprintf Solvable: "Foo = %o\n", Foo;
  // first try manual entry divisor if available
    if not ISA(Type(manual_divisor), RngIntElt) then
      /*
        vprintf Solvable: "Using manual divisor first:\n";
        D := manual_divisor;
        // TODO assert parent is correct?
        if Dimension(RiemannRochSpace(D)) eq 1 then
          vprintf Solvable: "Manual divisor yields 1 dimensional Lspace!\n";
        else
          error "Manual divisor does not appear to work.\n";
        end if;
      */
    else
      // make ramification divisor before BaseChange
        vprintf Solvable: "Try to find Ramification Divisor Before BaseChange:\n";
        time_start := Cputime();
        // worked_before_basechange, D := SolvableRamificationDivisor([ram0, ram1, ramoo], [*D0, D1, Doo*]);
        Dinitial := SolvableRamificationToDivisor([ram0, ram1, ramoo], [*D0, D1, Doo*]);
        if force_basechange then
          worked_before_basechange := false;
        else
          worked_before_basechange, D := SolvableRamificationDivisorUsingAllPoints(Dinitial);
        end if;
        time_end := Cputime();
      // update t with base change if necessary
      // NOTE this does not update t in the database, just to be used for s later
        if worked_before_basechange then
          vprintf Solvable: "OK found Ramification Divisor! That took %o seconds.\n", time_end-time_start;
          vprintf Solvable: "No need to BaseChange.\n";
        else
          vprintf Solvable: "BaseChanging...\n";
          vprintf Solvable: "Updating curve base field:\n";
          F := t`SolvableDBCurveBaseFieldList[#t`SolvableDBCurveBaseFieldList];
          vprintf Solvable: "Degree of current base field = %o\n", Degree(F);
          newF := Compositum(F, F0);
          vprintf Solvable: "Degree with F0 = %o.\n", Degree(newF);
          newF := Compositum(newF, F1);
          vprintf Solvable: "Degree with F1 = %o.\n", Degree(newF);
          newF := Compositum(newF, Foo);
          vprintf Solvable: "Degree with Foo = %o.\n", Degree(newF);
          t := SolvableBaseChange(t, newF);
          vprintf Solvable: "OK done. Here is the new field:\n%o\n", newF;
          assert t`SolvableDBCurveBaseFieldList[#t`SolvableDBCurveBaseFieldList] eq newF;
          vprintf Solvable: "Now updating divisors D0, D1, Doo.\n";
          // update D0, D1, Doo after base change
          X_below := t`SolvableDBBelyiCurve;
          phi_below := t`SolvableDBBelyiMap;
          DivX_below := DivisorGroup(X_below);
          if ram0 then
            D0 := Numerator(Divisor(phi_below));
            vprintf Solvable: "#supp(D0) after base change = %o.\n", #Support(D0);
          else
            D0 := DivX_below!0;
          end if;
          if ram1 then
            D1 := Numerator(Divisor(phi_below-1));
            vprintf Solvable: "#supp(D1) after base change = %o.\n", #Support(D1);
          else
            D1 := DivX_below!0;
          end if;
          if ramoo then
            Doo := Denominator(Divisor(phi_below));
            vprintf Solvable: "#supp(Doo) after base change = %o.\n", #Support(Doo);
          else
            Doo := DivX_below!0;
          end if;
          // make ramification divisor after BaseChange
          vprintf Solvable: "Finding Ramification Divisor After BaseChange:\n";
          time_start := Cputime();
          // worked_after_basechange, D := SolvableRamificationDivisor([ram0, ram1, ramoo], [*D0, D1, Doo*]);
          Dinitial := SolvableRamificationToDivisor([ram0, ram1, ramoo], [*D0, D1, Doo*]);
          worked_after_basechange, D := SolvableRamificationDivisorUsingAllPoints(Dinitial);
          time_end := Cputime();
          if worked_after_basechange then
            vprintf Solvable: "OK done! That took %o seconds.\n", time_end-time_start;
          else
            error "base change didn't help us find dimension 1 Lspace :(";
          end if;
        end if;
    end if;
  // RiemannRoch
    vprintf Solvable: "Applying RiemannRoch to following divisor:\n";
    supp, mult := Support(D);
    vprintf Solvable: "%o\n%o\n", supp, mult;
    LD, mpLDtoKX := RiemannRochSpace(D);
    assert Dimension(LD) eq 1;
    f := mpLDtoKX(LD.1);
    denom := Denominator(f);
    numer := Numerator(f);
    assert Parent(denom) eq Parent(numer);
    vprintf Solvable: "f = %o.\n", f;
    vprintf Solvable: "Numerator(f) = %o.\n", numer;
    vprintf Solvable: "Denominator(f) = %o.\n", denom;
  // now make the map
    vprintf Solvable: "Now constructing the curve and map.\n";
    AffAlg := Parent(denom);
    F := t`SolvableDBCurveBaseFieldList[#t`SolvableDBCurveBaseFieldList];
    l := s`SolvableDBLevel;
    // polynomial ring
    PX_below := t`SolvableDBCurvePolynomialRingList[#t`SolvableDBCurvePolynomialRingList];
    PX := eval Sprintf("PX<%o> := PolynomialRing(F, %o); return PX;", VarText("x", 0, l), l+1);
    // map from poly ring downstairs to poly ring upstairs
    mpPX_belowToPX := eval Sprintf("mpPX_belowToPX := hom< PX_below -> PX | %o >; return mpPX_belowToPX;", HomText("PX", 1, l));
    // map from parent(f) to poly ring upstairs
    mpAffAlgToPX := eval Sprintf("mpAffAlgToPX := hom< AffAlg -> PX | %o >; return mpAffAlgToPX;", HomText("PX", 1, l));
    // ideal downstairs
    I_below := t`SolvableDBCurveIdealList[#t`SolvableDBCurveIdealList];
    basis_below := Basis(I_below);
    // map basis into poly ring upstairs
    basis := [];
    for j := 1 to #basis_below do
      Append(~basis, mpPX_belowToPX(basis_below[j]));
    end for;
    // append new poly to basis coming
    Append(~basis, mpAffAlgToPX(denom)*PX.(l+1)^2-mpAffAlgToPX(numer));
    // ideal upstairs
    vprintf Solvable: "Apply PrimaryDecomposition:\n";
    I := ideal< PX | basis >;
    vprintf Solvable: "Ideal to start with:\n%o\n", I;
    Qs, Ps := PrimaryDecomposition(I);
    vprintf Solvable: "#Ps = %o:\n", #Ps;
    vprintf Solvable: "%o\n", Ps;
    // which Ps do you want?
    vprintf Solvable: "Checking for optional index.\n";
    if primary_index ne 0 then
      Ps_index := primary_index;
    else
      vprintf Solvable: "No optional index given. Choosing automagically.\n";
      Ps_index := -1;
      for i := 1 to #Ps do
        // TODO get a better idea about the curve...
        P := Ps[i];
        if Dimension(P) eq 1 then
          A := Spec(Parent(P.1));
          C := Curve(A,P);
          if Genus(C) eq s`SolvableDBGenus then
            Ps_index := i;
            break i;
          end if;
        end if;
      end for;
      if Ps_index lt 0 then
        error "No Ps worked with ease.";
      end if;
    end if;
    Ip := Ps[Ps_index];
    vprintf Solvable: "We picked Ps[%o]:\n%o\n", Ps_index, Ps[Ps_index];
    // curve upstairs
    vprintf Solvable : "Making ambient...";
    AA := eval Sprintf("AA<%o> := AffineSpace(PX); return AA;", VarText("x", 0, l));
    vprintf Solvable : "done.\n";
    vprintf Solvable : "Making curve...";
    // X := eval Sprintf("X<%o> := Curve(AA, Ip); return X;", VarText("x", 0, l));
    X := eval Sprintf("X<%o> := Curve(AA, Ip : Reduced := true, Irreducible := true); return X;", VarText("x", 0, l));
    vprintf Solvable : "done.\n";
    vprintf Solvable : "Making function field...";
    KX := eval Sprintf("KX<%o> := FunctionField(X); return KX;", VarText("x", 0, l));
    phi := KX.1;
    vprintf Solvable : "done.\n";
  // assign information to s
    s`SolvableDBCurveBaseFieldList := t`SolvableDBCurveBaseFieldList cat [* F *];
    s`SolvableDBCurvePolynomialRingList := t`SolvableDBCurvePolynomialRingList cat [* PX *];
    s`SolvableDBCurveAmbientList := t`SolvableDBCurveAmbientList cat [* AA *];
    s`SolvableDBCurveIdealList := t`SolvableDBCurveIdealList cat [* I *];
    s`SolvableDBCurveList := t`SolvableDBCurveList cat [* X *];
    s`SolvableDBBelyiCurve := X;
    s`SolvableDBBelyiMap := phi;
  return s;
end intrinsic;

/*
  intrinsic SolvableBelyiMap(s::SolvableDBObject) -> SolvableDBObject, Any
    {computes BelyiMap for s and returns s.}
    // assertions about children of s
      assert assigned s`SolvableDBChildren;
      assert #s`SolvableDBChildren ge 1;
      for i := 1 to #s`SolvableDBChildren do
        t := SolvableDBAccessEntry(s`SolvableDBChildren[i] cat ".m");
        assert SolvableMapSanityCheck(t);
      end for;
    // compute BelyiMaps using each child
    curve_list := [* *];
    for i := 1 to #s`SolvableDBChildren do
      // extract information from the child
        t := SolvableDBAccessEntry(s`SolvableDBChildren[i] cat ".m");
        F_below := t`SolvableDBCurveBaseFieldList[#t`SolvableDBCurveBaseFieldList];
        PX_below := t`SolvableDBCurvePolynomialRingList[#t`SolvableDBCurvePolynomialRingList];
        AA_below := t`SolvableDBCurveAmbientList[#t`SolvableDBCurveAmbientList];
        I_below := t`SolvableDBCurveIdealList[#t`SolvableDBCurveIdealList];
        X_below := t`SolvableDBCurveList[#t`SolvableDBCurveList];
        assert X_below eq t`SolvableDBBelyiCurve;
        phi_below := t`SolvableDBBelyiMap;
        abc_below := t`SolvableDBABC;
        abc := s`SolvableDBABC;
      // ramification above 0
        if abc_below[1] eq abc[1] then
          ram0 := false;
        else
          assert abc[1] eq 2*abc_below[1];
          ram0 := true;
        end if;
      // ramification above 1
        if abc_below[2] eq abc[2] then
          ram1 := false;
        else
          assert abc[2] eq 2*abc_below[2];
          ram1 := true;
        end if;
      // ramification above oo
        if abc_below[3] eq abc[3] then
          ramoo := false;
        else
          assert abc[3] eq 2*abc_below[3];
          ramoo := true;
        end if;
      // D0
      // TODO use built in functions instead
        support0, multiplicities0 := Support(Divisor(phi_below));
        D0 := DivisorGroup(X_below)!0;
        for i := 1 to #support0 do
          if multiplicities0[i] gt 0 then
            D0 +:= Divisor(support0[i]);
          end if;
        end for;
      // D1
        support1, multiplicities1 := Support(Divisor(phi_below-1));
        D1 := DivisorGroup(X_below)!0;
        for i := 1 to #support1 do
          if multiplicities1[i] gt 0 then
            D1 +:= Divisor(support1[i]);
          end if;
        end for;
      // Doo
        supportoo, multiplicitiesoo := Support(Divisor(1/phi_below));
        Doo := DivisorGroup(X_below)!0;
        for i := 1 to #supportoo do
          if multiplicitiesoo[i] gt 0 then
            Doo +:= Divisor(supportoo[i]);
          end if;
        end for;
      // make ramification divisor
      // TODO make this better :(
        if ram0 then
          if ram1 then
            if ramoo then
              // 0,1,oo ramified
              D := D0+D1-Doo;
            else
              // 0,1 ramified
              D := D0-D1;
            end if;
          else
            if ramoo then
              // 0,oo ramified
              D := D0-Doo;
            else
              // 0 ramified
              D := -D0;
            end if;
          end if;
        else
          if ram1 then
            if ramoo then
              // 1,oo ramified
              D := D1-Doo;
            else
              // 1 ramified
              D := D1;
            end if;
          else
            if ramoo then
              // oo ramified
              D := Doo;
            else
              // unramified
              error "unramified";
            end if;
          end if;
        end if;
      // RiemannRoch
        LD, mpLDtoKX := RiemannRochSpace(D);
        assert Dimension(LD) eq 1;
        f := mpLDtoKX(LD.1);
        denom := Denominator(f);
        numer := Numerator(f);
        assert Parent(denom) eq Parent(numer);
      // now make the map
        AffAlg := Parent(denom);
        F := F_below;
        // TODO deal with field extensions..
        l := s`SolvableDBLevel;
        // polynomial ring
        PX_below := t`SolvableDBCurvePolynomialRingList[#t`SolvableDBCurvePolynomialRingList];
        PX := eval Sprintf("PX<%o> := PolynomialRing(F, %o); return PX;", VarText("x", 0, l), l+1);
        // map from poly ring downstairs to poly ring upstairs
        mpPX_belowToPX := eval Sprintf("mpPX_belowToPX := hom< PX_below -> PX | %o >; return mpPX_belowToPX;", HomText("PX", 1, l));
        // map from parent(f) to poly ring upstairs
        mpAffAlgToPX := eval Sprintf("mpAffAlgToPX := hom< AffAlg -> PX | %o >; return mpAffAlgToPX;", HomText("PX", 1, l));
        // ideal downstairs
        I_below := t`SolvableDBCurveIdealList[#t`SolvableDBCurveIdealList];
        basis_below := Basis(I_below);
        // map basis into poly ring upstairs
        basis := [];
        for j := 1 to #basis_below do
          Append(~basis, mpPX_belowToPX(basis_below[j]));
        end for;
        // append new poly to basis coming
        Append(~basis, mpAffAlgToPX(denom)*PX.(l+1)^2-mpAffAlgToPX(numer));
        // ideal upstairs
        I := ideal< PX | basis >;
        Qs, Ps := PrimaryDecomposition(I);
        Ip := Ps[1];
        // curve upstairs
        AA := eval Sprintf("AA<%o> := AffineSpace(PX); return AA;", VarText("x", 0, l));
        // X := eval Sprintf("X<%o> := Curve(AA, Ip); return X;", VarText("x", 0, l));
        X := eval Sprintf("X<%o> := Curve(AA, Ip : Reduced := true, Irreducible := true); return X;", VarText("x", 0, l));
        KX := eval Sprintf("KX<%o> := FunctionField(X); return KX;", VarText("x", 0, l));
        phi := KX.1;
        Append(~curve_list, [* t`SolvableDBName, X, phi *]);
    end for;
    // assign information to s
    s`SolvableDBCurveBaseFieldList := t`SolvableDBCurveBaseFieldList cat [* F *];
    s`SolvableDBCurvePolynomialRingList := t`SolvableDBCurvePolynomialRingList cat [* PX *];
    s`SolvableDBCurveAmbientList := t`SolvableDBCurveAmbientList cat [* AA *];
    s`SolvableDBCurveIdealList := t`SolvableDBCurveIdealList cat [* I *];
    s`SolvableDBCurveList := t`SolvableDBCurveList cat [* X *];
    s`SolvableDBBelyiCurve := X;
    s`SolvableDBBelyiMap := phi;
    return s, curve_list;
  end intrinsic;
*/

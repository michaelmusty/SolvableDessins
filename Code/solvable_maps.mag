intrinsic SolvableMapSanityCheck(s::SolvableDBObject : lax := false) -> BoolElt
  {BelyiMapSanityCheck...solvableified.}
  if assigned s`SolvableDBGaloisOrbit and assigned s`SolvableDBBelyiCurve and assigned s`SolvableDBBelyiMap then
    t_start := Cputime();
    pass := s`SolvableDBGaloisOrbit;
    curve := s`SolvableDBBelyiCurve;
    map := s`SolvableDBBelyiMap;
    test_cycle_structure := SolvableCycleStructure(pass[1]);
    for i := 1 to #pass do
      assert SolvableCycleStructure(pass[i]) eq test_cycle_structure;
      // something is terribly wrong if this fails!
    end for;
    if not BelyiMapSanityCheck(pass[1], curve, map : lax := lax) then
      vprintf Solvable: "Solvable Sanity Failed:\n";
      vprintf Solvable: "sigma = \n%o.\n", pass[1];
      supp, mult := Support(Divisor(map));
      vprintf Solvable: "supp(phi) = \n%o\n%o.\n", supp, mult;
      supp1, mult1 := Support(Divisor(map-1));
      vprintf Solvable: "supp(phi-1) = \n%o\n%o.\n", supp1, mult1;
      return false;
    end if;
    // if we make it here then we passed!
    t_end := Cputime();
    s`SolvableDBSanityCheckTiming := t_end - t_start;
    return true;
  else
    return false;
  end if;
end intrinsic;

intrinsic SolvableLocalSanityCheck(s::SolvableDBObject, p::RngIntElt) -> BoolElt
  {SolvableMapSanityCheck...Localified...no lax!}
  if assigned s`SolvableDBGaloisOrbit and assigned s`SolvableDBBelyiCurve and assigned s`SolvableDBBelyiMap then
    // setup
      t_start := Cputime();
      pass := s`SolvableDBGaloisOrbit;
      curve := s`SolvableDBBelyiCurve;
      map := s`SolvableDBBelyiMap;
      test_cycle_structure := SolvableCycleStructure(pass[1]);
      for i := 1 to #pass do
        assert SolvableCycleStructure(pass[i]) eq test_cycle_structure;
        // something is terribly wrong if this fails!
      end for;
      vprintf Solvable : "Local sanity check setup done.\n";
    // reduce curve and Belyi map mod pp
      vprintf Solvable : "Reducing mod p = %o...", p;
      C, mapp := SolvableReduceCurve(curve, map, p);
      vprintf Solvable : "done.\n";
    // sanity check
      if not BelyiMapSanityCheck(pass[1], C, mapp) then
        vprintf Solvable: "Solvable Local Sanity Failed:\n";
        vprintf Solvable: "sigma = \n%o.\n", pass[1];
        supp, mult := Support(Divisor(mapp));
        vprintf Solvable: "supp(phi) = \n%o\n%o.\n", supp, mult;
        supp1, mult1 := Support(Divisor(mapp-1));
        vprintf Solvable: "supp(phi-1) = \n%o\n%o.\n", supp1, mult1;
        return false;
      end if;
    // if we make it here then we passed!
      t_end := Cputime();
      s`SolvableDBLocalSanityCheckTiming := t_end - t_start;
      s`SolvableDBLocalSanityCheckPrime := p;
      return true;
  else
    return false;
  end if;
end intrinsic;

intrinsic SolvablePolynomialReduction(poly::RngMPolElt, mp::Map, P::RngMPol) -> RngMPolElt
  {Given a poly and a mp on coefficients, return poly with new coeffs.}
  assert Codomain(mp) eq BaseRing(P);
  rank := Rank(P);
  assert rank eq Rank(Parent(poly));
  h := eval Sprintf("h := hom<Parent(poly)->P|[%o]>; return h;", VarText("P.", 1, rank));
  coeffs, mons := CoefficientsAndMonomials(poly);
  poly_pp := P!0;
  for i := 1 to #coeffs do
    poly_pp +:= P!(mp(coeffs[i])*h(mons[i]));
  end for;
  return poly_pp;
end intrinsic;

intrinsic SolvableReduceCurve(X::Crv, f::FldFunFracSchElt, p::RngIntElt) -> Crv, FldFunFracSchElt
  {Reduce X and f in QQ(X) mod p and return X mod p, f mod p.}
  // setup
    K := BaseField(X);
    if not IsProjective(X) then
      X := ProjectiveClosure(X);
    end if;
    ZK := Integers(K); // works for any K
    pp := Factorization(p*ZK)[1][1];
    FFq, mpZKtoFFq := ResidueClassField(pp);
    I := Ideal(X);
  // reduce I mod pp
    equations := Basis(I);
    equations_pp := []; // equations for Ipp
    grading := Grading(I);
    P := PolynomialRing(FFq, grading); // grading for CrvHyp
    for eqn in equations do
      eqn_pp := SolvablePolynomialReduction(eqn, mpZKtoFFq, P);
      Append(~equations_pp, eqn_pp);
    end for;
    Ipp := ideal<P|equations_pp>;
  // make new curve and coordinate rings
    PP := ProjectiveSpace(Generic(Ipp));
    Xpp := Curve(PP, Ipp);
    KXpp := FunctionField(Xpp);
    num := Numerator(f);
    den := Denominator(f);
    Aff := Parent(num);
    Affpp := Parent(Numerator(KXpp.1));
    h := eval Sprintf("hompp := hom<Aff->Affpp|[%o]>; return hompp;", VarText("Affpp.", 1, Rank(Affpp)));
  // make num in Affpp
    num_coeffs, num_mons := CoefficientsAndMonomials(num);
    numpp := Affpp!0;
    for i := 1 to #num_coeffs do
      numpp +:= Affpp!(mpZKtoFFq(num_coeffs[i])*h(num_mons[i]));
    end for;
  // make den in Affpp
    den_coeffs, den_mons := CoefficientsAndMonomials(den);
    denpp := Affpp!0;
    for i := 1 to #den_coeffs do
      denpp +:= Affpp!(mpZKtoFFq(den_coeffs[i])*h(den_mons[i]));
    end for;
  // coerce f into KXpp and return
    fpp := KXpp!(numpp)/KXpp!(denpp);
    return Xpp, fpp;
end intrinsic;

intrinsic SolvableIsUnramified(s::SolvableDBObject) -> BoolElt, MonStgElt
  {checks if s is unramified over any of its children and returns a bool and the child.}
  // fixed error when reading in PP1 if s has degree 2
  if s`SolvableDBDegree eq 2 then
    return false, "None";
  else
    assert assigned s`SolvableDBChildren;
    assert #s`SolvableDBChildren gt 0;
    children := s`SolvableDBChildren;
    sABC := s`SolvableDBABC;
    for i := 1 to #children do
      t := SolvableDBAccessEntry(children[i] cat ".m");
      tABC := t`SolvableDBABC;
      if sABC eq tABC then
        return true, children[i];
      end if;
    end for;
    // if we make it out of the loop then s is not ramified over any children
    return false, "None";
  end if;
end intrinsic;

intrinsic SolvableIsRamifiedAtEveryLevel(s::SolvableDBObject) -> BoolElt
  {true if s is ramified (at at least one point) at every intermediate level.}
  if s`SolvableDBDegree eq 2 then
    s`SolvableDBIsRamifiedAtEveryLevel := true;
    return true;
  else
    path := s`SolvableDBPathToPP1; // PP1, degree 2, degree 4, etc
    path_filenames := [];
    for i := #path to 2 by -1 do
      Append(~path_filenames, path[i] cat ".m");
    end for;
    unramified_bool := false;
    for i := 1 to #path_filenames-1 do
      top := SolvableDBAccessEntry(path_filenames[i]);
      bottom := SolvableDBAccessEntry(path_filenames[i+1]);
      topABC := top`SolvableDBABC;
      bottomABC := bottom`SolvableDBABC;
      if topABC eq bottomABC then
        unramified_bool := true;
      end if;
    end for;
    if unramified_bool then
      s`SolvableDBIsRamifiedAtEveryLevel := false;
      return false;
    else
      s`SolvableDBIsRamifiedAtEveryLevel := true;
      return true;
    end if;
  end if;
end intrinsic;

intrinsic SolvableBaseChange(s::SolvableDBObject, K::FldNum) -> SolvableDBObject
  {Extend base field of object to K.}
  // curve
    X := s`SolvableDBBelyiCurve;
    X := BaseChange(X, K);
    rk := Rank(Generic(Ideal(X)));
    curve_vars := VarSeq("x", 1, rk);
    AssignNames(~X, curve_vars);
    s`SolvableDBBelyiCurve := X;
  // map
    map := s`SolvableDBBelyiMap;
    KX := FunctionField(X);
    if IsProjective(X) then // X is CrvHyp
      map_vars := VarSeq("x", 1, rk-1);
    else // X is not CrvHyp and is affine
      map_vars := VarSeq("x", 1, rk);
    end if;
    AssignNames(~KX, map_vars);
  // initialize variables to base change the map
  num_vars := #map_vars;
  if num_vars eq 2 then
    x1 := KX.1;
    x2 := KX.2;
  elif num_vars eq 3 then
    x1 := KX.1;
    x2 := KX.2;
    x3 := KX.3;
  elif num_vars eq 4 then
    x1 := KX.1;
    x2 := KX.2;
    x3 := KX.3;
    x4 := KX.4;
  elif num_vars eq 5 then
    x1 := KX.1;
    x2 := KX.2;
    x3 := KX.3;
    x4 := KX.4;
    x5 := KX.5;
  else
    error "we should not be working in a high dimensional ambient space!";
  end if;
  phi := eval Sprintf("phi := KX!(%o); return phi;", map);
  s`SolvableDBBelyiMap := phi;
  // return
  return s;
end intrinsic;

intrinsic SolvableCheckResidueFields(D::DivCrvElt) -> BoolElt, Any
  {Computes the residue fields at places in support of D. Returns false, FldRat if these are all trivial. Returns true, Compositum of all residue fields if any residue fields are not trivial.}
  supp := Support(D);
  assert #supp gt 0;
  fields := [* *];
  non_trivial := false;
  for pt in supp do
    field := AbsoluteField(ResidueClassField(FunctionFieldPlace(pt)));
    if Degree(field) gt 1 then
      non_trivial := true;
    end if;
    Append(~fields, field);
  end for;
  if non_trivial eq false then
    return false, Rationals();
  else
    return_field := Rationals();
    for i := 1 to #fields do
      return_field := Compositum(return_field, fields[i]);
    end for;
    return true, AbsoluteField(return_field);
  end if;
end intrinsic;

intrinsic SolvableSetToDivisor(set::SetEnum[PlcCrvElt]) -> DivCrvElt
  {Given a set of places, return the divisor.}
  DivX := Parent(Divisor(Random(set)));
  D := DivX!0;
  for pt in set do
    D := D+Divisor(pt);
  end for;
  return D;
end intrinsic;

intrinsic SolvableRamificationDivisorUsingAllPoints(D::DivCrvElt) -> BoolElt, DivCrvElt
  {Attempt to find 1 dimensional Lspace using all points in D.}
  vprintf Solvable: "#supp(Divisor) = %o\n", #Support(D);
  worked := false;
  supp := Support(D);
  suppset := SequenceToSet(supp);
  subs := Subsets(suppset);
  for sub in subs do
    if #sub ne 0 and #sub ne #suppset then
      pos := SolvableSetToDivisor(sub);
      neg := SolvableSetToDivisor(suppset diff sub);
      supp, mult := Support(pos-neg);
      vprintf Solvable: "Checking divisor:\n%o\n%o\n", supp, mult;
      if Dimension(RiemannRochSpace(pos-neg)) eq 1 then
        vprintf Solvable: "It worked!\n";
        return true, pos-neg;
      else
        vprintf Solvable: "Didn't work >_<.\n";
      end if;
    end if;
  end for;
  return false, Parent(D)!0;
end intrinsic;

intrinsic SolvableDimensionOneLspacesUsingAllPoints(D::DivCrvElt) -> BoolElt, List
  {Find all 1 dimensional Lspace using all points in D. Return true if at least one such divisor.}
  supp := Support(D);
  suppset := SequenceToSet(supp);
  subs := Subsets(suppset);
  dimension_one_spaces := [* *];
  for sub in subs do
    if #sub ne 0 and #sub ne #suppset then
      pos := SolvableSetToDivisor(sub);
      neg := SolvableSetToDivisor(suppset diff sub);
      supp, mult := Support(pos-neg);
      vprintf Solvable: "Checking divisor:\n%o\n%o\n", supp, mult;
      if Dimension(RiemannRochSpace(pos-neg)) eq 1 then
        vprintf Solvable: "It worked!\n";
        Append(~dimension_one_spaces, pos-neg);
      else
        vprintf Solvable: "Didn't work >_<.\n";
      end if;
    end if;
  end for;
  if #dimension_one_spaces gt 0 then
    return true, dimension_one_spaces;
  else
    return false, [* Parent(D)!0 *];
  end if;
end intrinsic;

intrinsic SolvableRamificationToDivisor(ram::SeqEnum[BoolElt], Ds::List) -> DivCrvElt
  {Given ramification data and [D0, D1, Doo], return corresponding divisor.}
  assert #ram eq 3;
  ram0, ram1, ramoo := Explode(ram);
  assert #Ds eq 3;
  D0, D1, Doo := Explode(Ds);
  if ram0 then
    if ram1 then
      if ramoo then
        // 0,1,oo ramified
        return D0+D1+Doo;
      else
        // 0,1 ramified
        return D0+D1;
      end if;
    else
      if ramoo then
        // 0,oo ramified
        return D0+Doo;
      else
        // 0 ramified
        return D0;
      end if;
    end if;
  else
    if ram1 then
      if ramoo then
        // 1,oo ramified
        return D1+Doo;
      else
        // 1 ramified
        return D1;
      end if;
    else
      if ramoo then
        // oo ramified
        return Doo;
      else
        // unramified
        error "unramified...what?";
      end if;
    end if;
  end if;
end intrinsic;

intrinsic ExtractRoot(Y::Crv, f::FldFunFracSchElt, m::RngIntElt) -> Crv
  {Given a curve Y, and f in KY the function field of Y, return a new curve X with function field KX where KX = KY(mthroot(f)).}
  // assertions
    assert IsAffine(Y);
    KY := FunctionField(Y);
    assert Parent(f) eq KY;
  // ambient, ideal, polynomial ring of Y
    IY := Ideal(Y);
    PY := Generic(IY);
    AAY := Ambient(Y);
  // polynomial ring and ideal upstairs
    IYext, mp := VariableExtension(IY, 1, false); // mp: PY -> PX
    PX := Codomain(mp);
    assert PX eq Generic(IYext);
    AssignNames(~PX, VarSeq("x", 1, Rank(PX)));
  // map numerator and denominator of f into PX
    numer := mp(Numerator(f, Y));
    denom := mp(Denominator(f, Y));
  // basis of new ideal
    basis := Basis(IYext);
    new_equation := denom*PX.Rank(PX)^2-numer;
    Append(~basis, new_equation);
    IX := ideal< PX | basis >;
    S := Saturation(IX, numer); // saturate at numerator
    vprintf Solvable : "numerator...\n";
    // S := Saturation(IX, denom); // saturate at numerator
    // vprintf Solvable : "denominator...\n";
    assert IsPrime(S); // otherwise saturation didn't work
  // new ambient
    AAX := AffineSpace(PX);
  // make curve
    X := Curve(AAX, S);
    return X;
end intrinsic;

intrinsic SolvableAssignRamification(s::SolvableDBObject) -> SolvableDBObject
  {assigns [ram0, ram1, ramoo] to s.}
  t := Child(s);
  abc_below := t`SolvableDBABC;
  abc := s`SolvableDBABC;
  // ramification above 0
    if abc_below[1] eq abc[1] then
      ram0 := false;
    else
      assert abc[1] eq 2*abc_below[1];
      ram0 := true;
    end if;
  // ramification above 1
    if abc_below[2] eq abc[2] then
      ram1 := false;
    else
      assert abc[2] eq 2*abc_below[2];
      ram1 := true;
    end if;
  // ramification above oo
    if abc_below[3] eq abc[3] then
      ramoo := false;
    else
      assert abc[3] eq 2*abc_below[3];
      ramoo := true;
    end if;
  // assign to s and return s
  s`SolvableDBRamification := [ram0, ram1, ramoo];
  return s;
end intrinsic;

intrinsic SolvableAssignResidueFieldsAndDivisors(s::SolvableDBObject, t::SolvableDBObject) -> SolvableDBObject
  {assigns F0, F1, Foo to s.}
  assert assigned s`SolvableDBRamification;
  assert t`SolvableDBName eq Child(s)`SolvableDBName;
  ram0, ram1, ramoo := Explode(s`SolvableDBRamification);
  X_below := t`SolvableDBBelyiCurve;
  phi_below := t`SolvableDBBelyiMap;
  DivX_below := DivisorGroup(X_below);
  // ram0
    if ram0 then
      D0 := Numerator(Divisor(phi_below));
      _, F0 := SolvableCheckResidueFields(D0);
      vprintf Solvable: "D0 divisor:\n";
      supp0, mult0 := Support(D0);
      vprintf Solvable: "%o\n%o\n", supp0, mult0;
      vprintf Solvable: "D0 degree of residue fields: %o\n", Degree(F0);
      vprintf Solvable: "#supp(D0) before base change = %o.\n", #Support(D0);
    else
      vprintf Solvable: "D0 nothing to do.\n";
      D0 := DivX_below!0;
      F0 := Rationals();
    end if;
  // ram1
    if ram1 then
      D1 := Numerator(Divisor(phi_below-1));
      _, F1 := SolvableCheckResidueFields(D1);
      vprintf Solvable: "D1 divisor:\n";
      supp1, mult1 := Support(D1);
      vprintf Solvable: "%o\n%o\n", supp1, mult1;
      vprintf Solvable: "D1 degree of residue fields: %o\n", Degree(F1);
      vprintf Solvable: "#supp(D1) before base change = %o.\n", #Support(D1);
    else
      vprintf Solvable: "D1 nothing to do.\n";
      D1 := DivX_below!0;
      F1 := Rationals();
    end if;
  // ramoo
    if ramoo then
      Doo := Denominator(Divisor(phi_below));
      _, Foo := SolvableCheckResidueFields(Doo);
      vprintf Solvable: "Doo divisor:\n";
      suppoo, multoo := Support(Doo);
      vprintf Solvable: "%o\n%o\n", suppoo, multoo;
      vprintf Solvable: "Doo degree of residue fields: %o\n", Degree(Foo);
      vprintf Solvable: "#supp(Doo) before base change = %o.\n", #Support(Doo);
    else
      vprintf Solvable: "Doo nothing to do.\n";
      Doo := DivX_below!0;
      Foo := Rationals();
    end if;
  // assign and return
    vprintf Solvable: "ResidueFields:\n";
    vprintf Solvable: "F0 = %o\n", F0;
    vprintf Solvable: "F1 = %o\n", F1;
    vprintf Solvable: "Foo = %o\n", Foo;
    s`SolvableDBResidueField0 := F0;
    s`SolvableDBResidueField1 := F1;
    s`SolvableDBResidueFieldoo := Foo;
    s`SolvableDBDivisor0 := D0;
    s`SolvableDBDivisor1 := D1;
    s`SolvableDBDivisoroo := Doo;
    return s;
end intrinsic;

intrinsic SolvableBelyiMap(s::SolvableDBObject) -> SolvableDBObject
  {}
  // timing
    t_start := Cputime();
  // if s is unramified then stop and return s
    isunram := not SolvableIsRamifiedAtEveryLevel(s);
    if isunram then
      name := s`SolvableDBName;
      error Sprintf("%o is unramified at some level, no method to compute unramified covers (currently).\n", name);
    end if;
  // assertions about child of s
    vprintf Solvable: "So you want to compute a SolvableBelyiMap? Checking basic assertions.\n";
    time_start := Cputime();
    t := Child(s);
    time_end := Cputime();
    vprintf Solvable: "Done. That took %o seconds.\n", time_end-time_start;
  // [ram0, ram1, ramoo] a sequence of bools
    vprintf Solvable: "Determining ramification:\n";
    abc_below := t`SolvableDBABC;
    abc := s`SolvableDBABC;
    s := SolvableAssignRamification(s);
    ram0, ram1, ramoo := Explode(s`SolvableDBRamification);
    vprintf Solvable: "ABC before = %o.\n", abc_below;
    vprintf Solvable: "ramification = %o.\n", [ram0, ram1, ramoo];
    vprintf Solvable: "ABC after = %o.\n", abc;
  // assign residue fields F0, F1, Foo, and divisors D0, D1, Doo
    vprintf Solvable : "Assign residue fields and divisors to s...\n";
    t0 := Cputime();
    s := SolvableAssignResidueFieldsAndDivisors(s, t);
    F0 := s`SolvableDBResidueField0;
    F1 := s`SolvableDBResidueField1;
    Foo := s`SolvableDBResidueFieldoo;
    D0 := s`SolvableDBDivisor0;
    D1 := s`SolvableDBDivisor1;
    Doo := s`SolvableDBDivisoroo;
    t1 := Cputime();
    vprintf Solvable : "done. %o seconds.\n", t1-t0;
  // find dimension one Lspaces
    // try before base change
      vprintf Solvable: "Try to find dimension one L-spaces before base change:\n";
      Dinitial := SolvableRamificationToDivisor([ram0, ram1, ramoo], [*D0, D1, Doo*]); // divisor without basechange
      vprintf Solvable : "Initial ramification divisor computed.\n";
      vprintf Solvable : "First try without base change.\n";
      vprintf Solvable : "#supp(Divisor) = %o\n", #Support(Dinitial);
      vprintf Solvable : "Trying all combinations...";
      t0 := Cputime();
      worked_before_basechange, D := SolvableRamificationDivisorUsingAllPoints(Dinitial);
      s`SolvableDBRamificationDivisorBeforeBaseChange := D;
      t1 := Cputime();
      vprintf Solvable : "done. %o seconds.\n", t1-t0;
    // base change if necessary
      if worked_before_basechange then
        vprintf Solvable: "No need to BaseChange.\n";
      else
        // make composite of residue fields
          vprintf Solvable: "Base changing...\n";
          vprintf Solvable: "Updating curve base field:\n";
          F := BaseField(t`SolvableDBBelyiCurve);
          vprintf Solvable: "Degree of current base field = %o\n", Degree(F);
          newF := Compositum(F, F0);
          vprintf Solvable: "Degree with F0 = %o.\n", Degree(newF);
          newF := Compositum(newF, F1);
          vprintf Solvable: "Degree with F1 = %o.\n", Degree(newF);
          newF := Compositum(newF, Foo);
          vprintf Solvable: "Degree with Foo = %o.\n", Degree(newF);
          t := SolvableBaseChange(t, newF);
          vprintf Solvable: "OK done. Here is the new field:\n%o\n", newF;
          vprintf Solvable: "Now updating divisors D0, D1, Doo.\n";
        // update D0, D1, Doo after base change
          t0 := Cputime();
          s := SolvableAssignResidueFieldsAndDivisors(s, t);
          F0 := s`SolvableDBResidueField0;
          F1 := s`SolvableDBResidueField1;
          Foo := s`SolvableDBResidueFieldoo;
          D0 := s`SolvableDBDivisor0;
          D1 := s`SolvableDBDivisor1;
          Doo := s`SolvableDBDivisoroo;
          t1 := Cputime();
        // make ramification divisor after BaseChange
          vprintf Solvable: "Try to find dimension one L-spaces after base change:\n";
          Dinitial := SolvableRamificationToDivisor([ram0, ram1, ramoo], [*D0, D1, Doo*]);
          vprintf Solvable : "Initial divisor computed.\n";
          vprintf Solvable : "#supp(Divisor) = %o\n", #Support(Dinitial);
          vprintf Solvable : "Trying all combinations...";
          t0 := Cputime();
          worked_after_basechange, D := SolvableRamificationDivisorUsingAllPoints(Dinitial);
          s`SolvableDBRamificationDivisorAfterBaseChange := D;
          t1 := Cputime();
          vprintf Solvable : "done. %o seconds.\n", t1-t0;
          assert worked_after_basechange;
      end if;
  // setup curve downstairs
    X_below := t`SolvableDBBelyiCurve;
    phi_below := t`SolvableDBBelyiMap;
    if IsProjective(X_below) then // X_below is hyperelliptic so choose a patch
      X_below := AffinePatch(X_below, 1);
      assert IsAffine(X_below);
      KX_below := FunctionField(X_below);
      assert KX_below eq Parent(phi_below);
      num_vars := Rank(Generic(Ideal(X_below)));
      vars := VarSeq("x", 1, num_vars);
      AssignNames(~X_below, vars);
      AssignNames(~KX_below, vars);
      phi_below := KX_below!phi_below; // not necessary
    else
      assert IsAffine(X_below);
    end if;
  // RiemannRoch
    vprintf Solvable: "Applying RiemannRoch to following divisor:\n";
    supp, mult := Support(D);
    vprintf Solvable: "%o\n%o\n", supp, mult;
    LD, mpLDtoKX := RiemannRochSpace(D);
    assert Dimension(LD) eq 1;
    f := mpLDtoKX(LD.1);
    denom := Denominator(f, X_below);
    numer := Numerator(f, X_below);
    assert Parent(denom) eq Parent(numer);
    vprintf Solvable: "Parent(f) =\n%o\n", Parent(f);
    vprintf Solvable: "f = \n%o\n", f;
    vprintf Solvable: "Numerator(f) = %o.\n", numer;
    vprintf Solvable: "Denominator(f) = %o.\n", denom;
  // make the curve (brutal) using primary decomposition or (less brutal) use saturation
    vprintf Solvable : "Extracting root to make new curve...";
    t0 := Cputime();
    X := ExtractRoot(X_below, f, 2);
    t1 := Cputime();
    vprintf Solvable : "done. %o seconds.\n", t1-t0;
    vprintf Solvable : "Making new Belyi map...";
    KX := FunctionField(X);
    // making the new Belyi map requires a bit more care now that we are changing models
    rk_below := Rank(Generic(Ideal(X_below)));
    rk_above := Rank(Generic(Ideal(X)));
    assert rk_above eq rk_below+1;
    // projection map X -> X_below: [x1,x2,x3]->[x1,x2]
    map_text := VarText("X.", 1, rk_below);
    mp := eval Sprintf("mp := map< X->X_below | [%o] >; return mp;", map_text);
    // pullback phi_below under this map
    phi := Pullback(mp, phi_below);
    vprintf Solvable : "done.\n";
  // assertions
    vprintf Solvable : "Checking genus of curve...";
    assert s`SolvableDBGenus eq Genus(X);
    vprintf Solvable : "done.\n";
  // assign information to s and return s
    s`SolvableDBBelyiCurve := X;
    s`SolvableDBBelyiMap := phi;
  // timing
    t_end := Cputime();
    s`SolvableDBBelyiMapTiming := t_end - t_start;
  // return
    return s;
end intrinsic;

/*
// TODO update with low degree models
intrinsic SolvableBelyiMaps(d::RngIntElt) -> Any
  {Multiple calls to SolvableBelyiMapOptimized (singular) and returns the errors.}
  f := SolvableDBFilenames(d);
  errors := [];
  for i := 1 to #f do
    s := SolvableDBAccessEntry(f[i]);
    try
      time_start := Cputime();
      if (not SolvableIsUnramified(s)) and (not (assigned s`SolvableDBBelyiCurve)) then
        assert not assigned s`SolvableDBBelyiMap;
        s := SolvableBelyiMap(s);
        vprintf Solvable : "%o sanity check...", s`SolvableDBName;
        if SolvableMapSanityCheck(s) then
          vprintf Solvable : "done.\n";
          SolvableDBWriteObject(s);
        end if;
      end if;
      time_end := Cputime();
      vprintf Solvable : "%o time: %o\n", s`SolvableDBName, time_end-time_start;
    catch e
      print e;
      Append(~errors, e);
    end try;
  end for;
  return errors;
end intrinsic;
*/

intrinsic IsoText(var::MonStgElt, lower::RngIntElt, upper::RngIntElt) -> MonStgElt
  {returns text "var.lower, var.lower+1, ..., var.upper-1, var.upper".}
  assert upper ge lower;
  var_text := "";
  if upper eq lower then
    var_text *:= Sprintf("%o.%o", var, lower);
  else
    for i := lower to upper-1 by 1 do
      var_text *:= Sprintf("%o.%o, ", var, i);
    end for;
    var_text *:= Sprintf("%o.%o", var, upper);
  end if;
  return var_text;
end intrinsic;

intrinsic SolvableLowDegreeModel(s::SolvableDBObject) -> Any
  {Naively try to reduce the degree of the BelyiCurve.}
  vprintf Solvable : "%o LowDegreeAttempt :\n", s`SolvableDBName;
  curve_assigned := assigned s`SolvableDBBelyiCurve;
  map_assigned := assigned s`SolvableDBBelyiMap;
  if curve_assigned and map_assigned then
    t_start := Cputime();
    // make before and after objects
      before := SolvableDBObjectInitialize();
      after := SolvableDBObjectInitialize();
      attrs := GetAttributes(Type(s));
      for attr in attrs do
        if assigned s``attr then
          before``attr := s``attr;
          after``attr := s``attr;
        end if;
      end for;
    // setup for various cases
      vprintf Solvable : "  Belyi curve and map assigned.\n";
      X := before`SolvableDBBelyiCurve;
      assert IsAffine(X);
      X_proj := ProjectiveClosure(X);
      f := before`SolvableDBBelyiMap;
      degree_start := Degree(X_proj);
      vprintf Solvable : "  Degree of Belyi curve = %o.\n", degree_start;
      vprintf Solvable : "  Checking Canonical map...";
      t0 := Cputime();
      g, is_low_genus_or_hyp, mp := GenusAndCanonicalMap(X); // better to take projective closure?
      s`SolvableDBIsLowGenusOrHyperelliptic := is_low_genus_or_hyp;
      before`SolvableDBIsLowGenusOrHyperelliptic := is_low_genus_or_hyp;
      after`SolvableDBIsLowGenusOrHyperelliptic := is_low_genus_or_hyp;
      t1 := Cputime();
      vprintf Solvable : "done. %o seconds.\n", t1-t0;
    // cases
      if IsHyperelliptic(X) then
        assert is_low_genus_or_hyp;
        // computing hyperelliptic model
          vprintf Solvable : "  Curve is hyperelliptic.\n";
          vprintf Solvable : "  Computing hyperelliptic model...";
          t0 := Cputime();
          hyp_bool, hyp_H, hyp_mp := IsHyperelliptic(X);
          t1 := Cputime();
          vprintf Solvable : "done. %o seconds.\n", t1-t0;
          vprintf Solvable : "  Degree of new Belyi curve = %o.\n", Degree(hyp_H);
        // make new Belyi map, curve, and base field, assign to after object
          vprintf Solvable : "  Pushing forward Belyi map under iso...";
          g := Pushforward(hyp_mp, f);
          vprintf Solvable : "done.\n";
          X<x1, x2, x3> := hyp_H;
          KX<x1, x2> := FunctionField(X);
          assert KX eq Parent(g);
          K := BaseField(X);
          if Type(K) eq FldNum then
            K<nu> := BaseField(X);
          end if;
          after`SolvableDBBelyiCurve := X;
          after`SolvableDBBelyiMap := g; // not necessarily KX.1
        // timing and return
          t_end := Cputime();
          after`SolvableDBLowDegreeTiming := t_end - t_start;
          return before, after;
      else // g > 1 and curve is not hyperelliptic
        // computing new model
          vprintf Solvable : "  Curve is not hyperelliptic.\n";
          // TODO currently this timing block appears to take the most time
          t0 := Cputime();
          if Dimension(Ambient(X_proj)) eq 3 then
            printf "  Curve is already in PP3...";
            C := X_proj;
            g := f;
          else
            printf "  Projecting to PP3...";
            C, mp := EmbedPlaneCurveInP3(X); // the scheme is the codomain of mp
            assert IsProjective(Ambient(C));
            assert Curve(C) eq C;
            C := Curve(C);
            fix := map< X_proj -> C | DefiningEquations(mp) >;
            g := Pushforward(fix, f);
          end if;
          t1 := Cputime();
          vprintf Solvable : "done. %o seconds.\n", t1-t0;
          C := AffinePatch(C, 1); // TODO not pick blindly?
          I := Ideal(C);
          P := Generic(I);
          num_vars := Rank(P);
          Ceval := C;
          C := eval Sprintf("C<%o> := Ceval; return C;", VarText("x", 1, num_vars));
          KC := eval Sprintf("KC<%o> := FunctionField(C); return KC;", VarText("x", 1, num_vars-1));
          assert Parent(g) eq KC;
          K := BaseField(C);
          if ISA(Type(K), FldNum) then
            K<nu> := BaseField(C);
          end if;
          after`SolvableDBBelyiCurve := C;
          after`SolvableDBBelyiMap := g;
          assert Parent(g) eq KC;
          if not g eq KC.1 then
            vprintf Solvable : "  WARNING! new Belyi map is no longer KX.1\n";
          end if;
          Cproj := ProjectiveClosure(C);
          vprintf Solvable : "  Degree of new model = %o.\n", Degree(Cproj);
          // vprintf Solvable : "  Degree of new model = %o.\n", Degree(C);
        // bookkeeping and return
          assert Parent(g) eq FunctionField(C);
          t_end := Cputime();
          after`SolvableDBLowDegreeTiming := t_end - t_start;
          return before, after;
      end if;
  else
    vprintf Solvable : "Belyi map (or curve) is not assigned.\n";
    return s;
  end if;
end intrinsic;

declare type SolvableDBObject;
declare attributes SolvableDBObject:
  // easy attributes
  SolvableDBName,
  SolvableDBDegree,
  SolvableDBABC,
  SolvableDBType,
  SolvableDBGenus,
  SolvableDBSize,
  SolvableDBPointedSize,
  // permutation attributes
  SolvableDBPassport,
  SolvableDBPointedPassport,
  SolvableDBGaloisOrbits,
  SolvableDBMonodromyGroup,
  SolvableDBAutomorphismGroup,
  // Belyi map attributes
  SolvableDBBelyiCurves,
  SolvableDBBelyiMaps,
  // graph attributes
  SolvableDBParents,
  SolvableDBParentsUnramified,
  SolvableDBChildren,
  SolvableDBChildrenUnramified,
  // dessin attributes
  SolvableDBDessinCode;

// TODO equality in this way is quite silly...
intrinsic 'eq'(s::SolvableDBObject, t::SolvableDBObject) -> BoolElt
  {Return whether s is equal to t.}
  isSame := true;
  for attr in GetAttributes(Type(s)) do
    if Type(s``attr) ne Type(t``attr) then
      isSame := false;
    elif s``attr ne t``attr then
      isSame := false;
    end if;
  end for;
  return isSame;
end intrinsic;

intrinsic SolvableDBObjectInitialize() -> SolvableDBObject
  {Create an empty SolvableDBObject.}
  s := New(SolvableDBObject);
  return s;
end intrinsic;

intrinsic Print(s::SolvableDBObject)
  {Print SolvableDBObject}
  printf "SolvableDBObject %o:\n", s`SolvableDBName;
  printf "  Degree %o\n", s`SolvableDBDegree;
  printf "  Genus %o\n", s`SolvableDBGenus;
  printf "  %o\n", s`SolvableDBType;
  printf "  Size %o\n", s`SolvableDBSize;
  printf "  PointedSize %o\n", s`SolvableDBPointedSize;
  if assigned s`SolvableDBBelyiCurves and #s`SolvableDBBelyiCurves gt 0 then
    printf "  BelyiMaps computed :)\n";
    sane := true;
    pass := s`SolvableDBPassport;
    curves := s`SolvableDBBelyiCurves;
    maps := s`SolvableDBBelyiMaps;
    assert #pass eq #curves;
    assert #pass eq #maps;
    for i in [1..#pass] do
      if not BelyiMapSanityCheck(pass[i], curves[i], maps[i]) then
        sane := false;
      end if;
    end for;
    if sane then
      printf "    BelyiMaps passed sanity!\n";
    else
      printf "    BelyiMaps failed sanity!\n";
    end if;
  else
    printf "  BelyiMaps not computed yet :(\n";
  end if;
  printf "  Children:\n";
  if assigned s`SolvableDBChildren and #s`SolvableDBChildren gt 0 then
    for i in [1..#s`SolvableDBChildren] do
      printf "    %o\n", s`SolvableDBChildren[i];
    end for;
  else
    printf "    Children not computed yet :(\n";
  end if;
  printf "  Parents:\n";
  if assigned s`SolvableDBParents and #s`SolvableDBParents gt 0 then
    for i in [1..#s`SolvableDBParents] do
      printf "    %o\n", s`SolvableDBParents[i];
    end for;
  else
    printf "    Parents not computed yet :(\n";
  end if;
end intrinsic;

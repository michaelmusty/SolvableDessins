declare type SolvableDBObject;
declare attributes SolvableDBObject:
  // easy attributes
  SolvableDBName,
  SolvableDBFilename,
  SolvableDBPathNumber,
  SolvableDBDegree,
  SolvableDBABC,
  SolvableDBType,
  SolvableDBGenus,
  SolvableDBGaloisOrbitSize,
  SolvableDBPassportSize,
  SolvableDBPointedPassportSize,
  SolvableDBLevel,
  // permutation attributes
  SolvableDBGaloisOrbit,
  SolvableDBPassport,
  SolvableDBPointedPassport,
  SolvableDBMonodromyGroup,
  SolvableDBAutomorphismGroup,
  // curve function fields
  SolvableDBCurveBaseFieldList, // [F0, F1]
  SolvableDBCurvePolynomialRingList, // [PX0, PX1]
  SolvableDBCurveAmbientList, // [AA0, AA1]
  SolvableDBCurveIdealList, // [I0, I1]
  SolvableDBCurveList, // [X0, X1]
  // Belyi map attributes
  SolvableDBBelyiCurve, // X
  SolvableDBBelyiMap, // phi
  // graph attributes
  SolvableDBPathToPP1,
  SolvableDBParents,
  SolvableDBChildren,
  // dessin attributes
  SolvableDBDessinCode;

intrinsic Print(s::SolvableDBObject)
  {Print SolvableDBObject}
  printf "SolvableDBObject %o:\n", s`SolvableDBName;
  printf "  Degree %o\n", s`SolvableDBDegree;
  printf "  Genus %o\n", s`SolvableDBGenus;
  printf "  %o\n", s`SolvableDBType;
  printf "  Galois Orbit Size %o\n", s`SolvableDBGaloisOrbitSize;
  printf "  Passport Size %o\n", s`SolvableDBPassportSize;
  printf "  Pointed Passport Size %o\n", s`SolvableDBPointedPassportSize;
  if assigned s`SolvableDBBelyiCurve then
    printf "  BelyiMap computed :)\n";
    sane := true;
    pass := s`SolvableDBGaloisOrbit;
    curve := s`SolvableDBBelyiCurve;
    map := s`SolvableDBBelyiMap;
    if not BelyiMapSanityCheck(pass[1], curve, map) then
      sane := false;
    end if;
    if sane then
      printf "    BelyiMap passed sanity!\n";
    else
      printf "    BelyiMap failed sanity!\n";
    end if;
  else
    printf "  BelyiMap not computed yet :(\n";
  end if;
  if assigned s`SolvableDBPathToPP1 then
    printf "  PathToPP1:\n";
    printf "    %o\n", s`SolvableDBPathToPP1;
  end if;
  printf "  Children:\n";
  if assigned s`SolvableDBChildren and #s`SolvableDBChildren gt 0 then
    for i in [1..#s`SolvableDBChildren] do
      printf "    %o\n", s`SolvableDBChildren[i];
    end for;
  else
    printf "    Children not computed yet :(\n";
  end if;
  printf "  Parents:\n";
  if assigned s`SolvableDBParents and #s`SolvableDBParents gt 0 then
    for i in [1..#s`SolvableDBParents] do
      printf "    %o\n", s`SolvableDBParents[i];
    end for;
  else
    printf "    Parents not computed yet :(\n";
  end if;
end intrinsic;

intrinsic 'eq'(s::SolvableDBObject, t::SolvableDBObject) -> BoolElt
  {Return whether s is equal to t.}
  isSame := true;
  for attr in GetAttributes(Type(s)) do
    if Type(s``attr) ne Type(t``attr) then
      isSame := false;
    elif s``attr ne t``attr then
      isSame := false;
    end if;
  end for;
  return isSame;
end intrinsic;

intrinsic SolvableDBObjectInitialize() -> SolvableDBObject
  {Create an empty SolvableDBObject.}
  s := New(SolvableDBObject);
  return s;
end intrinsic;

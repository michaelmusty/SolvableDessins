// user defined verbose flags for vprintf
  declare verbose Solvable, 2;
  declare verbose SolvableTime, 1;

intrinsic SolvablePassportSort(l::SeqEnum[SeqEnum[GrpPermElt]]) -> SeqEnum[SeqEnum[SeqEnum[GrpPermElt]]]
  {Sort a SeqEnum of triples by simultaneous conjugation.}
  if #l eq 0 then
    return l;
  else
    d := Degree(l[1][1]);
    m := l;
    sorted := [];
    while #m gt 0 do
      test := m[1];
      assert #test eq 3;
      pass := [];
      Append(~pass, test);
      Remove(~m, 1);
      if #m eq 0 then
        Append(~sorted, pass);
        return sorted;
      else
        for i := #m to 1 by -1 do
          potential := m[i];
          assert #potential eq 3;
          if d gt 32 then
            test_name := SolvableDBGenerateNameAboveTransitiveDatabaseLimit(test);
            potential_name := SolvableDBGenerateNameAboveTransitiveDatabaseLimit(potential);
          else
            test_name := SolvableDBGenerateName(test);
            potential_name := SolvableDBGenerateName(potential);
          end if;
          if test_name eq potential_name then
            test_G := sub< Sym(d) | test >;
            potential_G := sub< Sym(d) | potential >;
            if IsIsomorphic(test_G, potential_G) then
              Remove(~m, i);
              if not IsConjugate(Sym(d), test, potential) then
                Append(~pass, potential);
              end if;
            end if;
          end if;
        end for;
        Append(~sorted, pass);
      end if;
    end while;
    return sorted;
  end if;
end intrinsic;

intrinsic SolvableAbove(s::SolvableDBObject) -> Any, Any
  {Given a solvableDBobj, find all Galois permutation triples "above" all permutation triples in the Galois orbit corresponding to s. Update the SolvableParents of s and return a SeqEnum of SolvableDBObjects covering s with their SolvableChildren updated accordingly.}
  pass := s`SolvableDBGaloisOrbit;
  new_covers_ramified := [];
  new_covers_unramified := [];
  for i := 1 to #pass do
    list0, list1, list_oo, all, possible, justramified, unramified, covers := PossibleGaloisCoveringPermutationTriples(pass[i] : return_everything := true);
    sorted_unramified := SolvablePassportSort(unramified);
    sorted_ramified := SolvablePassportSort(covers);
    // assert #unramified := &+[#sorted_unramified[i] : i in [1..#sorted_unramified]];
    // assert #ramified := &+[#sorted_ramified[i] : i in [1..#sorted_ramified]];
    for pass in sorted_unramified do
      t := SolvableDBExample(pass);
      // t needs some graph information to merge
      t`SolvableDBChildren := [Sprintf("%o", s`SolvableDBName)]; // t should have s as a child
      t`SolvableDBPathToPP1 := s`SolvableDBPathToPP1; // start path to t with s path
      Append(~t`SolvableDBPathToPP1, t`SolvableDBName); // t is the end of path to t
      t, is_new := SolvableDBMerge(t); // merge t with the database
      if is_new then // t is new and merged with database
        // update unramified parents of s
        assert s`SolvableDBABC eq t`SolvableDBABC;
        if not assigned s`SolvableDBParentsUnramified then
          s`SolvableDBParentsUnramified := []; // initialize if not assigned
        end if;
        Append(~s`SolvableDBParentsUnramified, Sprintf("%o", t`SolvableDBName)); // s should have t as a parent
        // TODO assertions before writing?
        // t already written to file
        SolvableDBWriteObject(s);
        Append(~new_covers_unramified, t);
      end if;
    end for;
    for pass in sorted_ramified do
      t := SolvableDBExample(pass);
      // t needs some graph information to merge
      t`SolvableDBChildren := [Sprintf("%o", s`SolvableDBName)]; // t should have s as a child
      t`SolvableDBPathToPP1 := s`SolvableDBPathToPP1; // start path to t with s path
      Append(~t`SolvableDBPathToPP1, t`SolvableDBName); // t is the end of path to t
      t, is_new := SolvableDBMerge(t); // merge t with the database
      if is_new then // t is new and merged with database
        // update ramified parents of s
        assert s`SolvableDBABC ne t`SolvableDBABC;
        if not assigned s`SolvableDBParents then
          s`SolvableDBParents := []; // initialize if not assigned
        end if;
        Append(~s`SolvableDBParents, Sprintf("%o", t`SolvableDBName)); // s should have t as a parent
        // TODO assertions before writing?
        // t already written to file
        SolvableDBWriteObject(s);
        Append(~new_covers_ramified, t);
      end if;
    end for;
  end for;
  return new_covers_ramified, new_covers_unramified;
end intrinsic;

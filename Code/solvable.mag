declare attributes GrpPerm: ClassesModAmbients;
declare attributes GrpPerm: NormalizerInAmbient;

 /* Auxiliary functions: */

intrinsic NormalizerInAmbient(G::GrpPerm) -> GrpPerm
  {Returns the normalizer of a permutation group in the symmetric group on its letters.}
  if assigned G`NormalizerInAmbient then
    return G`NormalizerInAmbient;
  end if;
  N := Normalizer(SymmetricGroup(Degree(G)), G);
  G`NormalizerInAmbient := N;
  return N;
end intrinsic;

intrinsic ConjugacyClass(G::GrpPerm, g::GrpPermElt) -> Tup
  {Returns the conjugacy class data for g as an element of G.}
  // NOTE: the following line is a lookup once it has been calculated before,
  // so no time is lost here. The same holds for later invocations.
  CCG := ConjugacyClasses(G);
  for CC in CCG do
    if IsConjugate(G, g, CC[3]) then
      return CC;
    end if;
  end for;
end intrinsic;

/* Conjugacy classes modulo ambient: */

intrinsic ConjugacyClassesModAmbient(G::GrpPerm, N::GrpPerm) -> SeqEnum[Tup]
  {Returns conjugacy classes representatives of G up to the conjugation action of N, where G is a subgroup of N.}
  ass := assigned G`ClassesModAmbients;
  test := false;
  if ass then
    test := N in [ class[1] : class in G`ClassesModAmbients ];
  end if;
  if test then
    return [ class[2] : class in G`ClassesModAmbients | class[1] eq N ][1];
  end if;
  CCG := ConjugacyClasses(G);
  if N eq G then
    CCGModN := [ tup : tup in CCG ];
  else
    CCGModN := [];
    for i in [1..#CCG] do
      done := false;
      for j in [1..#CCGModN] do
        if IsConjugate(N, CCG[i][3], CCGModN[j][3]) then
          CCGModN[j][2] +:= CCG[i][2];
          done := true;
          break;
        end if;
      end for;
      if not done then
        Append(~CCGModN, CCG[i]);
      end if;
    end for;
  end if;
  if not ass then
    G`ClassesModAmbients := [];
  end if;
  G`ClassesModAmbients cat:= [ [* N, CCGModN *] ];
  return CCGModN;
end intrinsic;

intrinsic ClassRepresentativesModAmbient(G::GrpPerm, N::GrpPerm) -> SeqEnum
  {Returns conjugacy class representatives of G up to the conjugation action of N, where G is a subgroup of N.}
  return [ class[3] : class in ConjugacyClassesModAmbient(G, N) ];
end intrinsic;

intrinsic ConjugacyClassModAmbient(G::GrpPerm, N::GrpPerm, g::GrpPermElt) -> Tup
  {Returns the conjugacy class data for g as an element of G, modulo ambient N.}
  CCGModN := ConjugacyClassesModAmbient(G, N);
  for CC in CCGModN do
    if IsConjugate(N, g, CC[3]) then
      return CC;
    end if;
  end for;
end intrinsic;

/* Some primitive lookups: */

intrinsic ConjugacyClassNumber(G::GrpPerm, g::GrpPermElt) -> Tup
  {Returns the conjugacy class number for g in the set of conjugacy classes of G. Note that this output is inconsistent, but not after the classes have been calculated once.}
  CCG := ConjugacyClasses(G);
  for i:=1 to #CCG do
    if IsConjugate(G, g, CCG[i][3]) then
      return i;
    end if;
  end for;
end intrinsic;

intrinsic ConjugacyClassNumber(G::GrpPerm, C::Tup) -> Tup
  {Returns the conjugacy class number for C in the set of conjugacy classes of G. Note that this output is inconsistent, but not after the classes have been calculated once.}
  return ConjugacyClassNumber(G, C[3]);
end intrinsic;

intrinsic ConjugacyClassModAmbientNumber(G::GrpPerm, N::GrpPerm, g::GrpElt) -> Tup
  {Returns the conjugacy class number for g in the set of conjugacy classes of G, up to the ambient N. Note that this output is inconsistent, but not after the classes have been calculated once.}
  CCGModN := ConjugacyClassesModAmbient(G, N);
  for i:=1 to #CCGModN do
    if IsConjugate(N, g, CCGModN[i][3]) then
      return i;
    end if;
  end for;
end intrinsic;

intrinsic ConjugacyClassModAmbientNumber(G::GrpPerm, N::GrpPerm, C::Tup) -> Tup
  {Returns the conjugacy class number for C in the set of conjugacy classes of G, up to the ambient N. Note that this output is inconsistent, but not after the classes have been calculated once.}
  CCGModN := ConjugacyClassesModAmbient(G, N);
  for i:=1 to #CCGModN do
    if IsConjugate(N, C[3], CCGModN[i][3]) then
      return i;
    end if;
  end for;
end intrinsic;

/* Weak equivalence: */

intrinsic S3Action(g::GrpPermElt, sigma::SeqEnum[GrpPermElt]) -> SeqEnum[GrpPermElt]
  {Transforms a Belyi map sigma by the left action of an element g of Sym(3).}
  assert Parent(g) eq Sym(3);
  assert #sigma eq 3;
  // This function of course also works for conjugacy class representatives.
  sigmap := [ sigma[i^g] : i in [1..#sigma] ];
  if IsOdd(g) then
    sigmap := [ s^(-1) : s in sigmap ];
  end if;
  return sigmap;
end intrinsic;

intrinsic S3Action(g::GrpPermElt, CCs::SeqEnum[Tup]) -> SeqEnum[Tup]
  {Transforms a triple of conjugacy classes CCs by the left action of an element g of Sym(3).}
  G := Parent(CCs[1][3]);
  CCG := ConjugacyClasses(G);
  if IsEven(g) then
    return [ CCs[i^g] : i in [1..#CCs] ];
  else
    return [ ConjugacyClass(G, CCs[i^g][3]^(-1)) : i in [1..#CCs] ];
  end if;
end intrinsic;

intrinsic S3Action(g::GrpPermElt, cycstrs::SeqEnum[SeqEnum[Tup]]) -> SeqEnum[SeqEnum[Tup]]
  {Transforms a triple of cycle structures cycstrs by the left action of an element g of Sym(3).}
  return [ cycstrs[i^g] : i in [1..#cycstrs] ];
end intrinsic;

intrinsic S3Action(g::GrpPermElt, inds::SeqEnum[RngIntElt], G::GrpPerm, N::GrpPerm) -> SeqEnum[RngIntElt]
  {Transforms a triple of conjugacy classes indices inds by the left action of an element g of Sym(3).}
  CCG := ConjugacyClassesModAmbient(G, N);
  if IsEven(g) then
    return [ inds[i^g] : i in [1..#inds] ];
  else
    return [ ConjugacyClassModAmbientNumber(G, N, CCG[inds[i^g]][3]^(-1)) : i in [1..#inds] ];
  end if;
end intrinsic;

intrinsic IsWeaklyIsomorphic(N::GrpPerm, sigma::SeqEnum[GrpPermElt], tau::SeqEnum[GrpPermElt]) -> BoolElt
  {Determines if two dessins sigma and tau are weakly isomorphic. These are supposed to generate the same monodromy group; N is a group containing this monodromy group that functions as an ambient.}
  gs := [ g : g in Sym(3) | &and[ IsConjugate(N, sigma[i^g], tau[i]) : i in [1..3] ] ];
  for g in gs do
    if IsConjugate(N, S3Action(g, sigma), tau) then
      return true;
    end if;
  end for;
  return false;
end intrinsic;

/* Representatives of conjugacy classes up to weak equivalence: */

intrinsic IsInCanonicalOrderC3(inds::SeqEnum[RngIntElt]) -> BoolElt
  {Determines if a triple of integers is ordered well with respect to rotation of the indices.}
  return ((inds[1] eq inds[2]) and (inds[1] eq inds[3])) or ((inds[1] le inds[2]) and (inds[1] lt inds[3]));
  // TODO: Incorporate this again.
  // We do not do the above because larger cycle types seems better:
  //return ((inds[1] eq inds[2]) and (inds[1] eq inds[3])) or ((inds[1] ge inds[2]) and (inds[1] gt inds[3]));
end intrinsic;

intrinsic CanonicalOrderC3(inds::SeqEnum[RngIntElt]) -> SeqEnum[RngIntElt]
  {Canonically orders a triple of integers with respect to rotation of the indices.}
  g0 := Sym(3)!(1,2,3);
  for e:=0 to 2 do
    g := g0^e;
    indsnew := [ inds[i^g] : i in [1..#inds] ];
    if IsInCanonicalOrderC3(indsnew) then
      return indsnew;
    end if;;
  end for;
end intrinsic;

// NOTE: We can also write this without a number encoding, see below. This is
// not used now; using indices seems just as good, and besides, using the
// number allows us to kill the C3 action immediately.
intrinsic S3Representatives(tups::SeqEnum[SeqEnum[RngIntElt]], G::GrpPerm, N::GrpPerm) -> SeqEnum[SeqEnum[RngIntElt]]
  {Given a set of triples of conjugacy classes, presumed stable under the action of Sym(3), determines a set of representatives under this action.  Uses group G and ambient N. Using a labeling.}
  CCGModN := ConjugacyClassesModAmbient(G, N);
  indss := tups;
  indss := [ inds : inds in indss | IsInCanonicalOrderC3(inds) ];
  if &and[ &and[ IsConjugate(N, CCGModN[ind][3], CCGModN[ind][3]^(-1)) : ind in inds ] : inds in indss ] then
    indss := [ inds : inds in indss | inds[2] le inds[3] ];
  else
    S2 := sub<Sym(3) | (1,2)>;
    indssxS2 := CartesianProduct(Set(indss), S2);
    // Note that we do get a right action here because the group has order 2:
    f := map< indssxS2 -> Set(indss) | tup :-> CanonicalOrderC3(S3Action(tup[2], tup[1], G, N)) >;
    indssGSet := GSet(S2, Set(indss), f);
    // Pick out one with a large conjugacy class:
    indss := [ Sort([ elt : elt in Set(orbit) ], func<L1,L2 | L2[1] - L1[1]>)[1] : orbit in Orbits(S2, indssGSet) ];
  end if;
  return indss;
end intrinsic;

// NOTE: Superfluous. Can also be modified to work with representatives (as above)
intrinsic S3Representatives(tups::SeqEnum[SeqEnum[Tup]], G::GrpPerm, N::GrpPerm) -> SeqEnum[SeqEnum[Tup]]
  {Given a set of triples of conjugacy classes, presumed stable under the action of Sym(3), determines a set of representatives under this action.  Uses group G and ambient N.}
  CCGModN := ConjugacyClassesModAmbient(G, N);
  indss := [ [ ConjugacyClassModAmbientNumber(G, N, CC) : CC in tup ] : tup in tups ];
  indss := [ inds : inds in indss | IsInCanonicalOrderC3(inds) ];
  if &and[ &and[ IsConjugate(N, CC[3], CC[3]^(-1)) : CC in tup ] : tup in tups ] then
    indss := [ inds : inds in indss | inds[2] le inds[3] ];
  else
    S2 := sub<Sym(3) | (1,2)>;
    indssxS2 := CartesianProduct(Set(indss), S2);
    // Note that we do get a right action here because the group has order 2:
    f := map< indssxS2 -> Set(indss) | tup :-> CanonicalOrderC3(S3Action(tup[2], tup[1], G, N)) >;
    r := Random(indss);
    indssGSet := GSet(S2, Set(indss), f);
    indss := [ Representative(Set(orbit)) : orbit in Orbits(S2, indssGSet) ];
  end if;
  return [ [ CCGModN[ind] : ind in inds ] : inds in indss ];
end intrinsic;

// In the big function, a much simpler version suffices; since we only use
// cycle types, we can sort directly.
intrinsic S3Representatives(tups::SeqEnum[SeqEnum[RngIntElt]]) -> SeqEnum[SeqEnum[RngIntElt]]
  {Returns tuples that are in order.}
  return [ tup : tup in Set([ Sort(tup) : tup in tups ]) ];
end intrinsic;

intrinsic S3Representative(tup::SeqEnum[RngIntElt]) -> SeqEnum[RngIntElt]
  {Orders a tuple.}
  return Sort(tup);
end intrinsic;

/* Solvable Specific: */

intrinsic S3Action(sigma::SeqEnum[GrpPermElt], g::GrpPermElt) -> SeqEnum[GrpPermElt]
  {Transforms a Belyi map sigma by the left action of an element g of Sym(3).}
  assert Parent(g) eq Sym(3);
  assert #sigma eq 3;
  // This function of course also works for conjugacy class representatives.
  sigmap := [ sigma[i^g] : i in [1..#sigma] ];
  if IsOdd(g) then
    sigmap := [ s^(-1) : s in sigmap ];
  end if;
  return sigmap;
end intrinsic;

intrinsic S3Action(parts::SeqEnum[SeqEnum[RngIntElt]], g::GrpPermElt) -> SeqEnum
  {Transforms a Belyi map partition triple by the right action of an element g of Sym(3).}
  G := Parent(g);
  assert G eq Sym(3);
  assert #parts eq 3;
  X := GSet(Sym(3), {1,2,3});
  l := [Image(g, X, 1), Image(g, X, 2), Image(g, X, 3)];
  partsp := [];
  for i in [1..#parts] do
    Append(~partsp, parts[l[i]]);
  end for;
  return partsp;
end intrinsic;

intrinsic SimultaneousConjugation(sigma::SeqEnum[GrpPermElt], g::GrpPermElt) -> SeqEnum[GrpPermElt]
  {Simultaneous conjugation of sigma by g.}
  assert #sigma eq 3;
  assert Degree(Parent(sigma[1])) eq Degree(Parent(g));
  return [ sigma[i]^g : i in [1,2,3] ];
end intrinsic;

intrinsic PermutationToPartition(perm::GrpPermElt) -> SeqEnum[RngIntElt]
  {See function name.}
  cs := CycleStructure(perm);
  part := [];
  for i in {1..#cs} do
    for j in {1..cs[i][2]} do
      Append(~part, cs[i][1]);
    end for;
  end for;
  return part;
end intrinsic;

intrinsic PermutationSheetify(sigma::GrpPermElt) -> GrpPermElt
  {Sheetifies the permutation...that is, if Degree(Parent(sigma[1])) is d, then use digits 0..d-1 for the permutations.}
  assert Type(Parent(sigma)) eq GrpPerm;
  d := Degree(Parent(sigma));
  S := Sym({  0..d-1 });
  one_line_sigmap := [];
  one_line_sigma := Eltseq(sigma);
  for i in {1..#one_line_sigma} do
    Append(~one_line_sigmap, one_line_sigma[i]-1);
  end for;
  sigmap := S!one_line_sigmap;
  return sigmap;
end intrinsic;

intrinsic PermutationsSheetify(sigma::SeqEnum) -> SeqEnum
  {Sheetifies the permutations...that is, if Degree(Parent(sigma[1])) is d, then use digits 0..d-1 for the permutations.}
  sigmap := [];
  for i in {1..#sigma} do
    Append(~sigmap, PermutationSheetify(sigma[i]));
  end for;
  return sigmap;
end intrinsic;

intrinsic ShapeOfCoveringPermutation(sigma::GrpPermElt, ram::SeqEnum[BoolElt]) -> SeqEnum[RngIntElt]
  {Given a permutation sigma of degree 2^i and ramification data, return a partition of 2^(i+1).}
  old_partition := PermutationToPartition(sigma);
  assert #ram eq #old_partition;
  new_partition := [];
  for i in [1..#old_partition] do
    if ram[i] then
      Append(~new_partition, 2*old_partition[i]);
    else
      if not ram[i] then
        Append(~new_partition, old_partition[i]);
        Append(~new_partition, old_partition[i]);
      else
        error "ramification data corrupt!";
      end if;
    end if;
  end for;
  return new_partition;
end intrinsic;

intrinsic ShapeOfCoveringPermutationTriple(sigma::SeqEnum[GrpPermElt], rams::SeqEnum[SeqEnum[BoolElt]]) -> SeqEnum[SeqEnum[RngIntElt]]
  {Given a permutation triple sigma of degree 2^i and ramification data, return three partitions of 2^(i+1).}
  assert #sigma eq 3;
  assert #rams eq 3;
  partitions := [];
  for i in [1..3] do
    Append(~partitions, ShapeOfCoveringPermutation(sigma[i], rams[i]));
  end for;
  return partitions;
end intrinsic;

intrinsic Excess(part::SeqEnum[RngIntElt]) -> RngIntElt
  {returns excess of partition.}
  return &+[part[i]-1 : i in [1..#part]];
end intrinsic;

intrinsic Excess(perm::GrpPermElt) -> RngIntElt
  {returns excess of permutation.}
  return Excess(PermutationToPartition(perm));
end intrinsic;

intrinsic IsGenusOfCoveringPartitions(parts::SeqEnum[SeqEnum[RngIntElt]], d::RngIntElt) -> BoolElt
  {Given a Belyi curve and a "degree d covering partition triple", return true if the genus of the Belyi curve for the partition triple according to Riemann-Hurwitz is an integer.}
  assert #parts eq 3;
  test_genus := 1-d+(Excess(parts[1])+Excess(parts[2])+Excess(parts[3]))/2;
  return Denominator(test_genus) eq 1 and test_genus ge 0;
end intrinsic;

intrinsic IsPossibleRamification(sigma::SeqEnum[GrpPermElt], rams::SeqEnum[SeqEnum[BoolElt]]) -> BoolElt
  {Checks if a given ramification above points corresponding to the cycles of sigma is possible according to Riemann-Hurwitz.}
  assert #sigma eq 3;
  assert #rams eq 3;
  d_below := Degree(sigma[1]);
  d_above := 2*d_below;
  parts := ShapeOfCoveringPermutationTriple(sigma, rams);
  if IsGenusOfCoveringPartitions(parts, d_above) then
    if #SequenceToSet(rams[1]) eq 1 and #SequenceToSet(rams[2]) eq 1 and #SequenceToSet(rams[3]) eq 1 then
      return true;
    else
      return false;
    end if;
  else
    return false;
  end if;
end intrinsic;

intrinsic IntegerToBinary(a::RngIntElt, e::RngIntElt) -> SeqEnum[RngIntElt]
  {returns sequence of length e corresponding to a in base 2.}
  assert a lt 2^e;
  reverse_digits := [];
  for i in [1..e] do
    digit := a mod 2;
    a := Integers()!((a-digit)/2);
    Append(~reverse_digits, digit);
  end for;
  return Reverse(reverse_digits);
end intrinsic;

intrinsic IntegerToRamification(a::RngIntElt, sigma::SeqEnum[GrpPermElt]) -> SeqEnum[SeqEnum[BoolElt]]
  {returns ramification given by integer a and triple sigma.}
  pts_above_zero := #CycleDecomposition(sigma[1]);
  pts_above_one := #CycleDecomposition(sigma[2]);
  pts_above_oo := #CycleDecomposition(sigma[3]);
  pts_above := [pts_above_zero, pts_above_one, pts_above_oo];
  // pts_above_zero, pts_above_one, pts_above_oo := Explode(pts_above);
  e := &+pts_above;
  binary := IntegerToBinary(a, e);
  ram_0 := [];
  ram_1 := [];
  ram_oo := [];
  for i in [1..pts_above_zero] do
    if binary[i] eq 1 then
      Append(~ram_0, true);
    else
      Append(~ram_0, false);
    end if;
  end for;
  for i in [pts_above_zero+1..pts_above_zero+pts_above_one] do
    if binary[i] eq 1 then
      Append(~ram_1, true);
    else
      Append(~ram_1, false);
    end if;
  end for;
  for i in [pts_above_zero+pts_above_one+1..pts_above_zero+pts_above_one+pts_above_oo] do
    if binary[i] eq 1 then
      Append(~ram_oo, true);
    else
      Append(~ram_oo, false);
    end if;
  end for;
  return [ram_0, ram_1, ram_oo];
end intrinsic;

intrinsic PossibleRamifications(sigma::SeqEnum[GrpPermElt]) -> SeqEnum[SeqEnum[SeqEnum[BoolElt]]]
  {Returns all possible ramifications above a given sigma.}
  assert #sigma eq 3;
  assert sigma[3]*sigma[2]*sigma[1] eq Id(Sym(Degree(sigma[1])));
  pts_above_zero := #PermutationToPartition(sigma[1]);
  pts_above_one := #PermutationToPartition(sigma[2]);
  pts_above_oo := #PermutationToPartition(sigma[3]);
  pts_above := [pts_above_zero, pts_above_one, pts_above_oo];
  e := &+pts_above;
  possible := [];
  for i in [0..2^e-1] do
    rams := IntegerToRamification(i, sigma);
    if IsPossibleRamification(sigma, rams) then
      Append(~possible, rams);
    end if;
  end for;
  return possible;
end intrinsic;

intrinsic PossibleShapesOfCoveringPermutationTriples(sigma::SeqEnum[GrpPermElt]) -> SeqEnum[SeqEnum[SeqEnum[RngIntElt]]]
  {returns triples of partitions possible in (degree 2) covering permutation triples of sigma according to Riemann-Hurwitz.}
  possible_rams := PossibleRamifications(sigma);
  l := [];
  for rams in possible_rams do
    Append(~l, ShapeOfCoveringPermutationTriple(sigma, rams));
  end for;
  // now kill S3 action in l
  ll := [];
  return l;
end intrinsic;

intrinsic IsExtension(G::GrpPerm, H::GrpPerm) -> BoolElt
  {True if there is a normal order 2 subgroup K of G with G/K isomorphic to H.}
  bool := false;
  lattice := SubgroupLattice(G);
  order_two_normal := [];
  for i in [1..#lattice] do
    K := lattice[i];
    if #K eq 2 and IsNormal(G, K) then
      Append(~order_two_normal, K);
    end if;
  end for;
  for i in [1..#order_two_normal] do
    if IsIsomorphic(G/order_two_normal[i], H) then
      bool := true;
    end if;
  end for;
  return bool;
end intrinsic;

intrinsic IdentifyingTau(n::RngIntElt) -> GrpPermElt
  {for n >= 2, returns tau identifying 2^n sheets to 2^(n-1) sheets}
  assert n gt 1;
  S := Sym(2^n);
  tau := Id(S);
  for i in [1..2^(n-1)] do
    tau := tau*S!(i,i+2^(n-1));
  end for;
  return tau;
end intrinsic;

intrinsic Mod(a::RngIntElt, b::RngIntElt) -> RngIntElt
  {if a <= b return a, if a > b return a mod b.}
  assert a le 2*b;
  if a lt b then
    return a;
  else
    if a mod b eq 0 then
      return b;
    else
      return a mod b;
    end if;
  end if;
end intrinsic;

intrinsic PermutationToCode(perm::GrpPermElt) -> SeqEnum[SeqEnum[RngIntElt]]
  {list encoding cycles of perm.}
  d := Degree(Parent(perm));
  fact := Factorization(d);
  assert IsDivisibleBy(d, 2) and #fact eq 1;
  cycles := CycleDecomposition(perm);
  code := [];
  for i in [1..#cycles] do
    cycle_code := [];
    for j in [1..#cycles[i]] do
      Append(~cycle_code, cycles[i][j]);
    end for;
    Append(~code, cycle_code);
  end for;
  return code;
end intrinsic;

intrinsic CodeToPermutation(code::SeqEnum[SeqEnum[RngIntElt]]) -> GrpPermElt
  {returns permutation corresponding to given code.}
  // find d and max length
  d := 1;
  max_length := 1;
  for i in [1..#code] do
    if #code[i] gt max_length then
      max_length := #code[i];
    end if;
    for j in [1..#code[i]] do
      if code[i][j] gt d then
        d := code[i][j];
      end if;
    end for;
  end for;
  // now we have d and max_length of a cycle
  fact := Factorization(d);
  assert IsDivisibleBy(d, 2) and #fact eq 1;
  // now we can construct the permutation from the code
  if max_length eq 1 then
    return Id(Sym(d));
  else
    SetColumns(0);
    str := "";
    for i in [1..#code] do
      str *:= "(";
      for j in [1..#code[i]-1] do
        str *:= Sprintf("%o, ", code[i][j]);
      end for;
      str *:= Sprintf("%o)", code[i][#code[i]]);
    end for;
    perm := eval Sprintf("Sym(%o)!%o", d, str);
    return perm;
  end if;
end intrinsic;

intrinsic ModifyCode(code::SeqEnum[SeqEnum[RngIntElt]], index::RngIntElt, new::RngIntElt) -> SeqEnum[SeqEnum[RngIntElt]]
  {returns modified code changing integer at position index to new.}
  ind := 1;
  for i in [1..#code] do
    for j in [1..#code[i]] do
      if ind eq index then
        code[i][j] := new;
      end if;
      ind +:= 1;
    end for;
  end for;
  return code;
end intrinsic;

intrinsic CodeEntry(code::SeqEnum[SeqEnum[RngIntElt]], index::RngIntElt) -> RngIntElt
  {returns code entry at index.}
  ind := 1;
  for i in [1..#code] do
    for j in [1..#code[i]] do
      if ind eq index then
        return code[i][j];
      end if;
      ind +:= 1;
    end for;
  end for;
end intrinsic;

intrinsic UnramifiedPossibilities(perm::GrpPermElt : zentral := true) -> SeqEnum[GrpPermElt]
  {all unramified permutations above perm.}
  d := Degree(Parent(perm));
  fact := Factorization(d);
  assert IsDivisibleBy(d, 2) and #fact eq 1;
  cycles := CycleDecomposition(perm);
  tau := IdentifyingTau(fact[1][2]+1);
  unramified := [];
  for i in [0..2^d-1] do
    // TODO seems like this should go outside for loop,
    // but somehow this changes something...
    code := PermutationToCode(perm);
    guide := IntegerToBinary(i, d);
    for j in [1..d] do
      new := Mod(CodeEntry(code, j) + d, 2*d);
      if guide[j] eq 1 then
        code := ModifyCode(code, j, new);
      end if;
    end for;
    ext_code := [];
    for j in [1..#code] do
      clone := [];
      for k in [1..#code[j]] do
        Append(~clone, Mod(code[j][k] + d, 2*d));
      end for;
      Append(~ext_code, code[j]);
      Append(~ext_code, clone);
    end for;
    s := Sym(2*d)!CodeToPermutation(ext_code);
    t := Sym(2*d)!tau;
    if zentral then
      if s*t eq t*s then
        Append(~unramified, s);
      end if;
    else
      Append(~unramified, s);
    end if;
  end for;
  return SetToSequence(SequenceToSet(unramified));
end intrinsic;

intrinsic RamifiedPossibilities(perm::GrpPermElt : zentral := true) -> SeqEnum[GrpPermElt]
  {all ramified permutations above perm.}
  d := Degree(Parent(perm));
  fact := Factorization(d);
  assert IsDivisibleBy(d, 2) and #fact eq 1;
  cycles := CycleDecomposition(perm);
  tau := IdentifyingTau(fact[1][2]+1);
  ramified := [];
  for i in [0..2^d-1] do
    // TODO seems like this should go outside for loop,
    // but somehow this changes something...
    code := PermutationToCode(perm);
    guide := IntegerToBinary(i, d);
    for j in [1..d] do
      new := Mod(CodeEntry(code, j) + d, 2*d);
      if guide[j] eq 1 then
        code := ModifyCode(code, j, new);
      end if;
    end for;
    new_code := [];
    for j in [1..#code] do
      new_cycle := code[j];
      for k in [1..#code[j]] do
        Append(~new_cycle, Mod(code[j][k]+d, 2*d));
      end for;
      Append(~new_code, new_cycle);
    end for;
    s := Sym(2*d)!CodeToPermutation(new_code);
    t := Sym(2*d)!tau;
    if zentral then
      if s*t eq t*s then
        Append(~ramified, s);
      end if;
    else
      Append(~ramified, s);
    end if;
  end for;
  return SetToSequence(SequenceToSet(ramified));
end intrinsic;

intrinsic PossibleGaloisCoveringPermutations(perm::GrpPermElt : zentral := true) -> SeqEnum[GrpPermElt]
  {a sequence of degree 2 Galois covering permutations possible after identifying sheets via tau.}
  return UnramifiedPossibilities(perm : zentral := zentral) cat RamifiedPossibilities(perm : zentral := zentral);
end intrinsic;

intrinsic PossibleGaloisCoveringPermutationTriples(sigma::SeqEnum[GrpPermElt] : zentral := true, brutal := false, lax := false, return_everything := false) -> SeqEnum[SeqEnum[GrpPermElt]]
  {return_everything yields: list_0, list_1, list_oo, all, possible, justramified, correct}
  d := Degree(Parent(sigma[1]));
  assert sigma[3]*sigma[2]*sigma[1] eq Id(Sym(d));
  // generate above each permutation
  printf "\n";
  printf "Generating possibilities above sigma0 = %o:\n", sigma[1];
  time0_1 := Cputime();
  list_0 := PossibleGaloisCoveringPermutations(sigma[1] : zentral := zentral);
  time0_2 := Cputime();
  printf "\tOK done! That took %o seconds.\n\n", time0_2 - time0_1;
  printf "Generating possibilities above sigma1 = %o:\n", sigma[2];
  time1_1 := Cputime();
  list_1 := PossibleGaloisCoveringPermutations(sigma[2] : zentral := zentral);
  time1_2 := Cputime();
  printf "\tOK done! That took %o seconds.\n\n", time1_2 - time1_1;
  printf "Generating possibilities above sigmaoo = %o:\n", sigma[3];
  timeoo_1 := Cputime();
  list_oo := PossibleGaloisCoveringPermutations(sigma[3] : zentral := zentral);
  timeoo_2 := Cputime();
  printf "\tOK done! That took %o seconds.\n\n", timeoo_2 - timeoo_1;
  all := [];
  possible := [];
  // filter out triples that can be Belyi maps
  time2 := Cputime();
  if brutal then
    printf "There are %o*%o*%o = %o possible covering triples:\n", #list_0, #list_1, #list_oo, #list_0*#list_1*#list_oo;
    printf "\tChecking which ones can be Belyi maps...USING BRUTAL APPROACH\n";
    for i in [1..#list_0] do
      for j in [1..#list_1] do
        for k in [1..#list_oo] do
          wt0 := list_0[i];
          wt1 := list_1[j];
          wtoo := list_oo[k];
          Append(~all, [wt0, wt1, wtoo]);
          if wtoo*wt1*wt0 eq Id(Sym(2*d)) then
            wtG := sub< Sym(2*d) | wt0, wt1, wtoo >;
            if IsTransitive(wtG) and #wtG eq (2*d) then
              Append(~possible, [wt0, wt1, wtoo]);
            end if;
          end if;
        end for;
      end for;
    end for;
  else // non-brutal
    // TODO sort lists so that we loop over the smaller ones
    printf "There are %o*%o*%o = %o possible covering triples:\n", #list_0, #list_1, #list_oo, #list_0*#list_1*#list_oo;
    printf "Looping over %o*%o = %o pairs of permutations:\n", #list_0, #list_1, #list_0*#list_1;
    printf "\tChecking which ones can be Belyi maps...USING LESS BRUTAL APPROACH\n";
    list_oo_inverses := [s^-1 : s in list_oo];
    for i in [1..#list_0] do
      for j in [1..#list_1] do
        wt0 := list_0[i];
        wt1 := list_1[j];
        Append(~all, [wt0, wt1]);
        if wt0*wt1 in list_oo_inverses then
          wtoo := (wt1*wt0)^-1;
          wtG := sub< Sym(2*d) | wt0, wt1, wtoo >;
          if IsTransitive(wtG) and #wtG eq (2*d) then
            Append(~possible, [wt0, wt1, wtoo]);
          end if;
        end if;
      end for;
    end for;
  end if;
  time3 := Cputime();
  printf "\tOK done! That took %o seconds.\n", time3-time2;
  printf "\tThere are %o possible covering triples that are Belyi maps.\n\n", #possible;
  // exclude unramified covers
  printf "Now eliminate unramified covers:\n";
  justramified := possible;
  time4 := Cputime();
  abc := [Order(sigma[i]) : i in [1..3]];
  for i := #justramified to 1 by -1 do
    abc_i := [Order(justramified[i][j]) : j in [1..3]];
    if abc eq abc_i then
      Remove(~justramified, i);
    end if;
  end for;
  time5 := Cputime();
  printf "\tOK done! That took %o seconds.\n", time5-time4;
  printf "\tThere are %o covering triples remaining.\n\n", #justramified;
  correct := justramified;
  // exclude isomorphic redundancies
  printf "Now eliminate redundancies:\n";
  time6 := Cputime();
  for i := #correct to 1 by -1 do
    for j in [1..i-1] do
      if lax then
        if IsWeaklyIsomorphic(Sym(2*d), correct[i], correct[j]) then
          Remove(~correct, i);
          break j;
        end if;
      else
        if IsConjugate(Sym(2*d), correct[i], correct[j]) then
          Remove(~correct, i);
          break j;
        end if;
      end if;
    end for;
  end for;
  time7 := Cputime();
  printf "\tOK done! That took %o seconds.\n", time7-time6;
  printf "\tThere are %o covering triples remaining.\n\n", #correct;
  if return_everything then
    return list_0, list_1, list_oo, all, possible, justramified, correct;
  else
    return correct;
  end if;
end intrinsic;

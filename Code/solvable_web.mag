intrinsic SolvableWebName(s::SolvableDBObject) -> MonStgElt
  {no path}
  sigma := s`SolvableDBGaloisOrbit[1];
  assert #sigma eq 3;
  H := Parent(sigma[1]);
  d := Degree(H);
  G := sub<Sym(d)|sigma>;
  assert IsTransitive(G);
  a,b,c := Explode([Order(sigma[1]), Order(sigma[2]), Order(sigma[3])]);
  if d gt 16 then
    d, g := Explode(IdentifyGroup(G)); // small group identification
    name := Sprintf("%oS%o-%o,%o,%o", d, g, a, b, c);
  else
    g, d := TransitiveGroupIdentification(G);
    name := Sprintf("%oT%o-%o,%o,%o", d, g, a, b, c);
  end if;
  c0 := #CycleDecomposition(sigma[1]);
  c1 := #CycleDecomposition(sigma[2]);
  coo := #CycleDecomposition(sigma[3]);
  genus := (d+2-c0-c1-coo)/2;
  name *:= Sprintf("-g%o", genus);
  return name;
end intrinsic;

intrinsic SolvableWebFilenames(d::RngIntElt) -> Any
  {for a degree d, sort names disregarding paths}
  f := SolvableDBFilenames(d);
  f_web := [];
  for i := 1 to #f do
    s := SolvableDBAccessEntry(f[i]);
    Append(~f_web, SolvableWebName(s));
  end for;
  return SetToSequence(SequenceToSet(f_web));
end intrinsic;

intrinsic SolvableNameToList(str::MonStgElt) -> SeqEnum
  {given a name from SolvableWebFilenames, return a SeqEnum of SolvableDBObjects that match that name after disregarding paths.}
  s := SolvableDBAccessEntry(str cat "-path1.m");
  d := s`SolvableDBDegree;
  f := SolvableDBFilenames(d);
  l := [];
  for i := 1 to #f do
    s := SolvableDBAccessEntry(f[i]);
    if str eq SolvableWebName(s) then
      Append(~l, s);
    end if;
  end for;
  return l;
end intrinsic;

intrinsic SolvableWebLists(d::RngIntElt) -> Any
  {}
  f := SolvableWebFilenames(d);
  l := [];
  vprintf Solvable : "# names = %o\n", #f;
  for i := 1 to #f do
    vprintf Solvable : "i = %o of %o\n", i, #f;
    Append(~l, SolvableNameToList(f[i]));
  end for;
  return l;
end intrinsic;

intrinsic SolvableEquationParse(str::MonStgElt) -> MonStgElt
  {}
  str_new := "";
  i := 1;
  while i le #str do
    if str[i] eq "x" then
      str_new *:= "x_";
    elif str[i] eq "y" then
      str_new *:= "y_";
    elif str[i] eq "^" then
      str_new *:= str[i];
      j := i+1;
      while (j lt #str) and (str[j] ne "*") and (str[j] ne " ") do
        if str[j] ne "*" then
          str_new *:= str[j];
        end if;
        j +:= 1;
      end while;
      if str[j] ne "*" then
        str_new *:= str[j];
      end if;
      i := j;
    elif str[i] eq "n" then
      assert str[i+1] eq "u";
      str_new *:= "\\n";
    elif str[i] eq "*" then
      str_new *:= "";
    elif str[i] eq "u" then
      str_new *:= "u ";
    else
      str_new *:= str[i];
    end if;
    i +:= 1;
  end while;
  return str_new;
end intrinsic;

intrinsic SolvableCurveText(s::SolvableDBObject) -> SeqEnum[MonStgElt]
  {}
  equations := DefiningEquations(s`SolvableDBBelyiCurve);
  equations_str := [];
  for eqn in equations do
    eqn_str := SolvableEquationParse(Sprintf("%o", eqn));
    eqn_str := Sprintf("\\(%o\\)", eqn_str);
    Append(~equations_str, eqn_str);
  end for;
  return equations_str;
end intrinsic;

intrinsic SolvableMapText(s::SolvableDBObject) -> MonStgElt, MonStgElt
  {}
  map := s`SolvableDBBelyiMap;
  num := Numerator(map);
  den := Denominator(map);
  num_text := SolvableEquationParse(Sprintf("%o", num));
  den_text := SolvableEquationParse(Sprintf("%o", den));
  num_text := Sprintf("\\(%o\\)", num_text);
  den_text := Sprintf("\\(%o\\)", den_text);
  return num_text, den_text;
end intrinsic;

intrinsic SolvableMathJax(s::SolvableDBObject) -> MonStgElt, MonStgElt
  {}
  curve_text := "";
  map_text := "";
  assert assigned s`SolvableDBBelyiCurve;
  assert assigned s`SolvableDBBelyiMap;
  curve_text := SolvableCurveText(s); // list
  num_text, den_text := SolvableMapText(s);
  return curve_text, num_text, den_text;
end intrinsic;

intrinsic SolvableWebGraphFiles(d::RngIntElt) -> MonStgElt
  {generate all graph files for d equals 4 or larger.}
  lists := SolvableWebLists(d);
  for i := 1 to #lists do
    vprintf Solvable : "i = %o out of %o\n", i, #lists;
    l := lists[i];
    name := SolvableWebName(l[1]);
    filename := Sprintf("%o-graph.html", name);
    str := SolvableWebGraphText(l);
    Write(Sprintf("web_files/%o", filename), str : Overwrite := true);
  end for;
  return_text := Sprintf("Successfully wrote %o web graph files for degree %o\n", #lists, d);
  return return_text;
end intrinsic;

intrinsic SolvableWebGraphText(l::SeqEnum[SolvableDBObject]) -> MonStgElt
  {given a list of SolvableDBObjects (all with the same webname), produce html text for name-graph.html file}
  // setup
    name, children, parents := SolvableWebGraphTextSetup(l);
    str := "";
  // head
    str *:= Sprintf("<!doctype html>\n");
    str *:= Sprintf("<html lang=\"en\">\n");
    str *:= Sprintf("  <head>\n");
    str *:= Sprintf("    <title>%o | graph</title>\n", name);
    str *:= Sprintf("    <meta charset=\"UTF-8\">\n");
    str *:= Sprintf("    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n");
    str *:= Sprintf("    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n");
    str *:= Sprintf("    <script type=\"text/javascript\" src=\"vis.min.js\"></script>\n");
    str *:= Sprintf("    <link type=\"text/css\" href=\"vis-network.min.css\">\n");
    str *:= Sprintf("    <link href=\"entireframework.min.css\" rel=\"stylesheet\" type=\"text/css\">\n");
    str *:= Sprintf("    <link rel=\"shortcut icon\" href=\"favicon.png\" type=\"image/x-icon\">\n");
    str *:= Sprintf("    <script type=\"text/javascript\"\n");
    str *:= Sprintf("      src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML\">\n");
    str *:= Sprintf("    </script>\n");
    str *:= Sprintf("    <style type=\"text/css\">\n");
    str *:= Sprintf("      html, body { padding: 0; margin: 0; width: 100%%; height: 100%%; } #mynetwork { width: 100%%; height: 100%%; border: 1px solid #444444; background-color: white; }\n");
    str *:= Sprintf("    </style>\n");
    str *:= Sprintf("  </head>\n");
  // body html
    str *:= Sprintf("  <body>\n");
    str *:= Sprintf("    <nav class=\"nav\" onclick=\"this.focus()\">\n");
    str *:= Sprintf("      <div class=\"container\">\n");
    str *:= Sprintf("        <a class=\"pagename current\" href=\"index.html\">dessin explorer</a>\n");
    str *:= Sprintf("      </div>\n");
    str *:= Sprintf("    </nav>\n");
    str *:= Sprintf("    <div class=\"container\">\n");
    str *:= Sprintf("      <h2>%o</h2>\n", name);
    str *:= Sprintf("    </div>\n");
    str *:= Sprintf("    <div class=\"container\">\n");
    str *:= Sprintf("      <div class=\"row\">\n");
    str *:= Sprintf("        <a class=\"btn btn-a smooth\" href=\"%o-graph.html\">graph</a>\n", name);
    str *:= Sprintf("        <a class=\"btn btn-b smooth\" href=\"%o-data.html\">data</a>\n", name);
    str *:= Sprintf("      </div>\n");
    str *:= Sprintf("    </div>\n");
    str *:= Sprintf("    <div class=\"container\">\n");
    str *:= Sprintf("      <div id=\"mynetwork\"></div>\n");
    str *:= Sprintf("    </div>\n");
  // body script
    str *:= Sprintf("    <script type=\"text/javascript\">\n");
    str *:= Sprintf("      var layoutMethod = \"directed\";\n");
    str *:= Sprintf("      var nodes = new vis.DataSet([\n");
    // center node
    str *:= Sprintf("        {id: 'c', label: '%o', group: 'simple', url: '%o-graph.html'},\n", name, name);
    // children nodes
    for i := 1 to #children do
      child := children[i];
      str *:= Sprintf("        {id: 'b%o', label: '%o', group: 'simple', url:'%o-graph.html'},\n", i, child, child);
    end for;
    // parents nodes
    for i := 1 to #parents do
      parent := parents[i];
      str *:= Sprintf("        {id: 'a%o', label: '%o', group: 'simple', url:'%o-graph.html'},\n", i, parent, parent);
    end for;
    str *:= Sprintf("      ]);\n");
    str *:= Sprintf("      var edges = new vis.DataSet([\n");
    // center -> children
    for i := 1 to #children do
      str *:= Sprintf("        {from: 'c', to: 'b%o'},\n", i);
    end for;
    // parents -> center
    for i := 1 to #parents do
      str *:= Sprintf("        {from: 'a%o', to: 'c'},\n", i);
    end for;
    str *:= Sprintf("      ]);\n");
    str *:= Sprintf("      var container = document.getElementById('mynetwork');\n");
    str *:= Sprintf("      var data = {\n");
    str *:= Sprintf("        nodes: nodes,\n");
    str *:= Sprintf("        edges: edges\n");
    str *:= Sprintf("      };\n");
    str *:= Sprintf("      var options = { nodes: { shape: 'box', size: 15, font: { size: 15, }, borderWidth: 1, shadow: true }, edges: { width: 2, shadow: true, smooth: true, arrows: {to : true } }, groups: { simple: { color: {background: 'white', border: 'black'} }, sizeN: { color: {background: 'red', border: 'black'} } }, interaction: { hover: true, zoomView: false }, layout: { randomSeed: 2, hierarchical: { sortMethod: layoutMethod } }, };\n");
    str *:= Sprintf("      var network = new vis.Network(container, data, options);\n");
    str *:= Sprintf("      let yMin = Number.MAX_SAFE_INTEGER\n");
    str *:= Sprintf("      let yMax = Number.MIN_SAFE_INTEGER\n");
    str *:= Sprintf("      nodes.forEach(node => {\n");
    str *:= Sprintf("        const boundingBox = network.getBoundingBox(node.id)\n");
    str *:= Sprintf("        if(boundingBox.top < yMin)\n");
    str *:= Sprintf("          yMin = boundingBox.top\n");
    str *:= Sprintf("        if(boundingBox.bottom > yMax)\n");
    str *:= Sprintf("          yMax = boundingBox.bottom\n");
    str *:= Sprintf("      })\n");
    str *:= Sprintf("      const heightOffset = 50\n");
    str *:= Sprintf("      const naturalHeight = yMax - yMin + heightOffset\n");
    str *:= Sprintf("      container.style.height = naturalHeight + 'px'\n");
    str *:= Sprintf("      network.redraw()\n");
    str *:= Sprintf("      network.fit()\n");
    str *:= Sprintf("      container.style.height = network.getScale() * naturalHeight + 'px'\n");
    str *:= Sprintf("      network.redraw()\n");
    str *:= Sprintf("      network.fit()\n");
    str *:= Sprintf("      network.on(\"click\", function(params) {\n");
    str *:= Sprintf("        if (params.nodes.length === 1) {\n");
    str *:= Sprintf("          var node = nodes.get(params.nodes[0]);\n");
    str *:= Sprintf("          window.open(node.url, '_self');\n");
    str *:= Sprintf("        }\n");
    str *:= Sprintf("      });\n");
    str *:= Sprintf("    </script>\n");
    str *:= Sprintf("  </body>\n");
  // end
  str *:= Sprintf("</html>");
  return str;
end intrinsic;

intrinsic SolvableWebGraphTextSetup(l::SeqEnum[SolvableDBObject]) -> Any
  {given a list of SolvableDBObjects (all with the same webname), produce name, children, parents for input to SolvableWebGraphText.}
  // name
    for s in l do
      assert SolvableWebName(s) eq SolvableWebName(l[1]);
    end for;
    name := SolvableWebName(l[1]);
  // children
  if l[1]`SolvableDBDegree eq 2 then
    children := ["PP1"];
  else
    children_web_names := [SolvableWebName(Child(l[i])) : i in [1..#l]];
    children := SetToSequence(SequenceToSet(children_web_names));
  end if;
  // parents
  parent_web_names := [];
  for i := 1 to #l do
    parent_names := [SolvableWebName(Parents(l[i])[j]) : j in [1..#Parents(l[i])]];
    parent_web_names cat:= parent_names;
  end for;
  parents := SetToSequence(SequenceToSet(parent_web_names));
  return name, children, parents;
end intrinsic;

intrinsic SolvableGroupHelper(d::RngIntElt, g::RngIntElt) -> SeqEnum[MonStgElt]
  {given degree and group number return a SeqEnum of pathless names with those parameters.}
  f := SolvableDBFilenames(d);
  names := [];
  for i := 1 to #f do
    vprintf Solvable : "i = %o out of %o\n", i, #f;
    s := SolvableDBAccessEntry(f[i]);
    G := s`SolvableDBMonodromyGroup;
    if d gt 16 then
      _, g_test := Explode(IdentifyGroup(G));
    else
      g_test := TransitiveGroupIdentification(G);
    end if;
    if g_test eq g then
      Append(~names, SolvableWebName(s));
    end if;
  end for;
  return SetToSequence(SequenceToSet(names));
end intrinsic;

intrinsic SolvableIndexHelper(d::RngIntElt, g::RngIntElt) -> MonStgElt
  {return html text for buttons...}
  names := SolvableGroupHelper(d, g);
  str := "";
  str *:= Sprintf("    <div class=\"container\">\n");
  if d gt 16 then
    str *:= Sprintf("      <h3>%oS%o</h3>\n", d, g);
  else
    str *:= Sprintf("      <h3>%oT%o</h3>\n", d, g);
  end if;
  for name in names do
    str *:= Sprintf("      <a class=\"btn btn-sm smooth\" href=\"%o-graph.html\">%o</a>\n", name, name);
  end for;
  str *:= Sprintf("    </div>\n");
  return str;
end intrinsic;

intrinsic SolvableWebDataText(l::SeqEnum[SolvableDBObject]) -> MonStgElt
  {given a list of SolvableDBObjects (all with the same webname), produce html text for name-data.html file}
  // name, children, parents
    for s in l do
      assert SolvableWebName(s) eq SolvableWebName(l[1]);
    end for;
    name, children, parents := SolvableWebGraphTextSetup(l);
  // type
    for s in l do
      assert s`SolvableDBType eq l[1]`SolvableDBType;
    end for;
    type := l[1]`SolvableDBType;
  // degree
    for s in l do
      assert s`SolvableDBDegree eq l[1]`SolvableDBDegree;
    end for;
    degree := l[1]`SolvableDBDegree;
  // genus
    for s in l do
      assert s`SolvableDBGenus eq l[1]`SolvableDBGenus;
    end for;
    genus := l[1]`SolvableDBGenus;
  // galois orbit size
    for s in l do
      assert #s`SolvableDBGaloisOrbit eq #l[1]`SolvableDBGaloisOrbit;
    end for;
    galois_orbit_size := #l[1]`SolvableDBGaloisOrbit;
  // sigma0
    sigma0 := Sprintf("%o", l[1]`SolvableDBGaloisOrbit[1][1]);
  // sigma1
    sigma1 := Sprintf("%o", l[1]`SolvableDBGaloisOrbit[1][2]);
  // sigmaoo
    sigmaoo := Sprintf("%o", l[1]`SolvableDBGaloisOrbit[1][3]);
  // passport size
    for s in l do
      assert #s`SolvableDBPassport eq #l[1]`SolvableDBPassport;
    end for;
    passport_size := #l[1]`SolvableDBPassport;
  // pointed size
    for s in l do
      assert #s`SolvableDBPointedPassport eq #l[1]`SolvableDBPointedPassport;
    end for;
    pointed_size := #l[1]`SolvableDBPointedPassport;
  // belyi curve
  // belyi map numerator
  // belyi map denominator
  // belyi curve degree
  // belyi curve measure
end intrinsic;

// TODO
intrinsic SolvableWebDataFiles(d::RngIntElt) -> MonStgElt
  {}
end intrinsic;

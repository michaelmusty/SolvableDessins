intrinsic SolvableWebName(s::SolvableDBObject) -> MonStgElt
  {no path}
  sigma := s`SolvableDBGaloisOrbit[1];
  assert #sigma eq 3;
  H := Parent(sigma[1]);
  d := Degree(H);
  G := sub<Sym(d)|sigma>;
  assert IsTransitive(G);
  a,b,c := Explode([Order(sigma[1]), Order(sigma[2]), Order(sigma[3])]);
  if d gt 16 then
    d, g := Explode(IdentifyGroup(G)); // small group identification
    name := Sprintf("%oS%o-%o,%o,%o", d, g, a, b, c);
  else
    g, d := TransitiveGroupIdentification(G);
    name := Sprintf("%oT%o-%o,%o,%o", d, g, a, b, c);
  end if;
  c0 := #CycleDecomposition(sigma[1]);
  c1 := #CycleDecomposition(sigma[2]);
  coo := #CycleDecomposition(sigma[3]);
  genus := (d+2-c0-c1-coo)/2;
  name *:= Sprintf("-g%o", genus);
  return name;
end intrinsic;

intrinsic SolvableWebFilenames(d::RngIntElt) -> Any
  {for a degree d, sort names disregarding paths}
  f := SolvableDBFilenames(d);
  f_web := [];
  for i := 1 to #f do
    s := SolvableDBAccessEntry(f[i]);
    Append(~f_web, SolvableWebName(s));
  end for;
  return SetToSequence(SequenceToSet(f_web));
end intrinsic;

intrinsic SolvableNameToList(str::MonStgElt) -> SeqEnum
  {given a name from SolvableWebFilenames, return a SeqEnum of SolvableDBObjects that match that name after disregarding paths.}
  s := SolvableDBAccessEntry(str cat "-path1.m");
  d := s`SolvableDBDegree;
  f := SolvableDBFilenames(d);
  l := [];
  for i := 1 to #f do
    s := SolvableDBAccessEntry(f[i]);
    if str eq SolvableWebName(s) then
      Append(~l, s);
    end if;
  end for;
  return l;
end intrinsic;

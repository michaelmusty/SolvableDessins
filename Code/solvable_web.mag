intrinsic SolvableWebName(s::SolvableDBObject) -> MonStgElt
  {no path}
  sigma := s`SolvableDBGaloisOrbit[1];
  assert #sigma eq 3;
  H := Parent(sigma[1]);
  d := Degree(H);
  G := sub<Sym(d)|sigma>;
  assert IsTransitive(G);
  a,b,c := Explode([Order(sigma[1]), Order(sigma[2]), Order(sigma[3])]);
  if d gt 16 then
    d, g := Explode(IdentifyGroup(G)); // small group identification
    name := Sprintf("%oS%o-%o,%o,%o", d, g, a, b, c);
  else
    g, d := TransitiveGroupIdentification(G);
    name := Sprintf("%oT%o-%o,%o,%o", d, g, a, b, c);
  end if;
  c0 := #CycleDecomposition(sigma[1]);
  c1 := #CycleDecomposition(sigma[2]);
  coo := #CycleDecomposition(sigma[3]);
  genus := (d+2-c0-c1-coo)/2;
  name *:= Sprintf("-g%o", genus);
  return name;
end intrinsic;

intrinsic SolvableWebFilenames(d::RngIntElt) -> Any
  {for a degree d, sort names disregarding paths}
  f := SolvableDBFilenames(d);
  f_web := [];
  for i := 1 to #f do
    s := SolvableDBAccessEntry(f[i]);
    Append(~f_web, SolvableWebName(s));
  end for;
  return SetToSequence(SequenceToSet(f_web));
end intrinsic;

intrinsic SolvableNameToList(str::MonStgElt) -> SeqEnum
  {given a name from SolvableWebFilenames, return a SeqEnum of SolvableDBObjects that match that name after disregarding paths.}
  s := SolvableDBAccessEntry(str cat "-path1.m");
  d := s`SolvableDBDegree;
  f := SolvableDBFilenames(d);
  l := [];
  for i := 1 to #f do
    s := SolvableDBAccessEntry(f[i]);
    if str eq SolvableWebName(s) then
      Append(~l, s);
    end if;
  end for;
  return l;
end intrinsic;

intrinsic SolvableWebLists(d::RngIntElt) -> Any
  {}
  f := SolvableWebFilenames(d);
  l := [];
  vprintf Solvable : "# names = %o\n", #f;
  for i := 1 to #f do
    vprintf Solvable : "i = %o of %o\n", i, #f;
    Append(~l, SolvableNameToList(f[i]));
  end for;
  return l;
end intrinsic;

// TODO ^
intrinsic SolvableEquationParse(str::MonStgElt) -> MonStgElt
  {}
  str_new := "";
  i := 1;
  while i lt #str do
    if str[i] eq "x" then
      str_new *:= "x_";
    elif str[i] eq "y" then
      str_new *:= "y_";
    elif str[i] eq "^" then
      str_new *:= str[i];
      j := i+1;
      while (j lt #str) and (str[j] ne "*") and (str[j] ne " ") do
        if str[j] ne "*" then
          str_new *:= str[j];
        end if;
        j +:= 1;
      end while;
      if str[j] ne "*" then
        str_new *:= str[j];
      end if;
      i := j;
    elif str[i] eq "n" then
      assert str[i+1] eq "u";
      str_new *:= "\\n";
    elif str[i] eq "*" then
      str_new *:= "";
    elif str[i] eq "u" then
      str_new *:= "u ";
    else
      str_new *:= str[i];
    end if;
    i +:= 1;
  end while;
  return str_new;
end intrinsic;

intrinsic SolvableHyperellipticCurveText(s::SolvableDBObject) -> MonStgElt
  {}
  // just make sure names are correct to pass to SolvableCurveText
end intrinsic;

intrinsic SolvableCurveText(s::SolvableDBObject) -> MonStgElt
  {}
end intrinsic;

intrinsic SolvableMapText(s::SolvableDBObject) -> MonStgElt
  {}
  map := s`SolvableDBBelyiMap;
  num := Numerator(map);
  den := Denominator(map);
  num_text := SolvableEquationParse(Sprintf("%o", num));
  den_text := SolvableEquationParse(Sprintf("%o", den));
  return Sprintf("\\((%o)/(%o)\\)", num_text, den_text);
end intrinsic;

intrinsic SolvableMathJax(s::SolvableDBObject) -> MonStgElt, MonStgElt
  {}
  curve_text := "";
  map_text := "";
  assert assigned s`SolvableDBBelyiCurve;
  assert assigned s`SolvableDBBelyiMap;
  if s`SolvableDBIsLowGenusOrHyperelliptic and s`SolvableDBGenus gt 1 then
    curve_text := SolvableHyperellipticCurveText(s);
  else
    curve_text := SolvableCurveText(s);
  end if;
  map_text := SolvableMapText(s);
  return curve_text, map_text;
end intrinsic;

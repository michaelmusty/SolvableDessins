AttachSpec("spec");
directory := "/Users/mjmusty/Dropbox/github/SolvableDessins/SolvableDB";
ChangeDirectory(directory);

/*
degree 2
*/

// 2T1
d2 := [Sym(2) | (1,2),(1,2),Id(Sym(2))];

/*
degree 4
*/

// 4T1_1
s4t1_1 := SolvableDBAccessEntry("4T1-[4,4,1]-4-4-1111-g0.m");
p4t1_1 := s4t1_1`SolvableDBPointedPassport;
d4t1_1 := p4t1_1[1];

// 4T1_2
s4t1_2 := SolvableDBAccessEntry("4T1-[4,4,2]-4-4-22-g1.m");
p4t1_2 := s4t1_2`SolvableDBPointedPassport;
d4t1_2 := p4t1_2[1];

// 4T2
s4t2 := SolvableDBAccessEntry("4T2-[2,2,2]-22-22-22-g0.m");
p4t2 := s4t2`SolvableDBPointedPassport;
d4t2 := p4t2[1];

/*
degree 8
*/

// 8T1_1
s8t1_1 := SolvableDBAccessEntry("8T1-[8,8,1]-8-8-11111111-g0.m");
p8t1_1 := s8t1_1`SolvableDBPointedPassport;
d8t1_1 := p8t1_1[1];

// 8T1_2
s8t1_2 := SolvableDBAccessEntry("8T1-[8,8,2]-8-8-2222-g2.m");
p8t1_2 := s8t1_2`SolvableDBPointedPassport;
d8t1_2 := p8t1_2[1];

// 8T1_3
s8t1_3 := SolvableDBAccessEntry("8T1-[8,8,4]-8-8-44-g3.m");
p8t1_3 := s8t1_3`SolvableDBPointedPassport;
d8t1_3 := p8t1_3[1];

// 8T2
s8t2 := SolvableDBAccessEntry("8T2-[4,4,2]-44-44-2222-g1.m");
p8t2 := s8t2`SolvableDBPointedPassport;
d8t2 := p8t2[1];

// 8T4
s8t4 := SolvableDBAccessEntry("8T4-[2,2,4]-2222-2222-44-g0.m");
p8t4 := s8t4`SolvableDBPointedPassport;
d8t4 := p8t4[1];

// 8T5
s8t5 := SolvableDBAccessEntry("8T5-[4,4,4]-44-44-44-g2.m");
p8t5 := s8t5`SolvableDBPointedPassport;
d8t5 := p8t5[1];

/*
sigma := SimultaneousConjugation(d4[3], Sym(4)!(1,3));
sigma := SimultaneousConjugation(d4[2], Sym(4)!(1,3));
sigma := d4[1];

d := Degree(Parent(sigma[1]));
assert sigma[3]*sigma[2]*sigma[1] eq Id(Sym(d));
list_0 := PossibleGaloisCoveringPermutations(sigma[1]);
list_1 := PossibleGaloisCoveringPermutations(sigma[2]);
list_oo := PossibleGaloisCoveringPermutations(sigma[3]);
all := [];
triple := [];
not_triple := [];
transitive := [];
not_transitive := [];
order := [];
not_order := [];
for i in [1..#list_0] do
  for j in [1..#list_1] do
    for k in [1..#list_oo] do
      wt0 := list_0[i];
      wt1 := list_1[j];
      wtoo := list_oo[k];
      sigmap := [wt0, wt1, wtoo];
      Append(~all, sigmap);
      if wtoo*wt1*wt0 eq Id(Sym(2*d)) then
        Append(~triple, sigmap);
        wtG := sub< Sym(2*d) | wt0, wt1, wtoo >;
        if IsTransitive(wtG) then
          Append(~transitive, sigmap);
          if #wtG eq (2*d) then
            Append(~order, sigmap);
          else
            Append(~not_order, sigmap);
          end if;
        else
          Append(~not_transitive, sigmap);
        end if;
      else
        Append(~not_triple, sigmap);
      end if;
    end for;
  end for;
end for;
correct := order;
for i := #correct to 1 by -1 do
  for j in [1..i-1] do
    if IsWeaklyIsomorphic(Sym(2*d), correct[i], correct[j]) then
      Remove(~correct, i);
      break j;
    end if;
  end for;
end for;

// sigma := [Sym(8)|(1,2,3,4,5,6,7,8),(1,6,3,8,5,2,7,4),(1,5)(2,6)(3,7)(4,8)];

d8_1 := PossibleGaloisCoveringPermutationTriples(d4[3]);
d8_2 := PossibleGaloisCoveringPermutationTriples(d4[2]);
d8_3 := PossibleGaloisCoveringPermutationTriples(d4[1]);

for i in [1..#d8_1] do
  assert IsTransitive(sub< Sym(8) | d8_1[i] >);
  assert d8_1[i][3]*d8_1[i][2]*d8_1[i][1] eq Id(Sym(8));
  bool := true;
  for j in [1..#d8_1] do
    if i ne j and IsWeaklyIsomorphic(Sym(8), d8_1[i], d8_1[j]) then
      bool := false;
    end if;
  end for;
  assert bool;
end for;

for i in [1..#d8_2] do
  assert IsTransitive(sub< Sym(8) | d8_2[i] >);
  assert d8_2[i][3]*d8_2[i][2]*d8_2[i][1] eq Id(Sym(8));
  bool := true;
  for j in [1..#d8_2] do
    if i ne j and IsWeaklyIsomorphic(Sym(8), d8_2[i], d8_2[j]) then
      bool := false;
    end if;
  end for;
  assert bool;
end for;
for i in [1..#d8_3] do
  assert IsTransitive(sub< Sym(8) | d8_3[i] >);
  assert d8_3[i][3]*d8_3[i][2]*d8_3[i][1] eq Id(Sym(8));
  bool := true;
  for j in [1..#d8_3] do
    if i ne j and IsWeaklyIsomorphic(Sym(8), d8_3[i], d8_3[j]) then
      bool := false;
    end if;
  end for;
  assert bool;
end for;
*/
